<?xml version="1.0"?>
<doc>
  <assembly>
    <name>QuickGraph</name>
  </assembly>
  <members>
    <member name="T:QuickGraph.IGraph`2">
      <summary>
            A graph with vertices of type <typeparamref name="TVertex" />
            and edges of type <typeparamref name="TEdge" /></summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="P:QuickGraph.IGraph`2.IsDirected">
      <summary>
            Gets a value indicating if the graph is directed
            </summary>
    </member>
    <member name="P:QuickGraph.IGraph`2.AllowParallelEdges">
      <summary>
            Gets a value indicating if the graph allows parallel edges
            </summary>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredGraph`3.BaseGraph">
      <summary>
            Underlying filtered graph
            </summary>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredGraph`3.EdgePredicate">
      <summary>
            Edge predicate used to filter the edges
            </summary>
    </member>
    <member name="T:QuickGraph.EdgeEventArgs`2">
      <summary>
            An event involving an edge.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
    </member>
    <member name="M:QuickGraph.EdgeEventArgs`2.#ctor(`1)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.EdgeEventArgs`2" /> class.
            </summary>
      <param name="edge">The edge.</param>
      <requires>edge != null</requires>
    </member>
    <member name="P:QuickGraph.EdgeEventArgs`2.Edge">
      <summary>
            Gets the edge.
            </summary>
      <value>The edge.</value>
    </member>
    <member name="T:QuickGraph.EdgeAction`2">
      <summary>
            The handler for events involving edges
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="e" />
    </member>
    <member name="T:QuickGraph.IMutableUndirectedGraph`2">
      <summary>
            A mutable indirect graph
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="T:QuickGraph.IMutableEdgeListGraph`2">
      <summary>
            A mutable edge list graph.
            </summary>
      <typeparam name="TVertex">the vertex type</typeparam>
      <typeparam name="TEdge">the edge type</typeparam>
    </member>
    <member name="T:QuickGraph.IMutableGraph`2">
      <summary>
            A mutable graph instance
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="M:QuickGraph.IMutableGraph`2.Clear">
      <summary>
            Clears the vertex and edges
            </summary>
    </member>
    <member name="E:QuickGraph.IMutableGraph`2.Cleared">
      <summary>
            Called when the graph vertices and edges have been cleared.
            </summary>
    </member>
    <member name="T:QuickGraph.IEdgeListGraph`2">
      <summary>
            A graph whose edges can be enumerated
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.IEdgeSet`2">
      <summary>
            A set of edges
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
    </member>
    <member name="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)">
      <summary>
            Determines whether the specified edge contains edge.
            </summary>
      <param name="edge">The edge.</param>
      <returns>
        <c>true</c> if the specified edge contains edge; otherwise, <c>false</c>.
            </returns>
      <pure />
      <requires>edge != null</requires>
      <ensures>Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="P:QuickGraph.IEdgeSet`2.IsEdgesEmpty">
      <summary>
            Gets a value indicating whether there are no edges in this set.
            </summary>
      <value>
        <c>true</c> if this set is empty; otherwise, <c>false</c>.
            </value>
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.IEdgeSet`2.EdgeCount">
      <summary>
            Gets the edge count.
            </summary>
      <value>The edge count.</value>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.IEdgeSet`2.Edges">
      <summary>
            Gets the edges.
            </summary>
      <value>The edges.</value>
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures>Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="T:QuickGraph.IVertexSet`1">
      <summary>
            A set of vertices
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
    </member>
    <member name="T:QuickGraph.IImplicitVertexSet`1">
      <summary>
            An implicit set of vertices
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
    </member>
    <member name="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)">
      <summary>
            Determines whether the specified vertex contains vertex.
            </summary>
      <param name="vertex">The vertex.</param>
      <returns>
        <c>true</c> if the specified vertex contains vertex; otherwise, <c>false</c>.
            </returns>
      <pure />
      <requires>vertex != null</requires>
    </member>
    <member name="P:QuickGraph.IVertexSet`1.IsVerticesEmpty">
      <summary>
            Gets a value indicating whether there are no vertices in this set.
            </summary>
      <value>
        <c>true</c> if the vertex set is empty; otherwise, <c>false</c>.
            </value>
      <getter>
        <ensures>Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.IVertexSet`1.VertexCount">
      <summary>
            Gets the vertex count.
            </summary>
      <value>The vertex count.</value>
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.IVertexSet`1.Vertices">
      <summary>
            Gets the vertices.
            </summary>
      <value>The vertices.</value>
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)">
      <summary>
            Adds the edge to the graph
            </summary>
      <param name="edge" />
      <returns>true if the edge was added, otherwise false.</returns>
      <requires>e != null</requires>
      <requires>ithis.ContainsVertex(e.Source)</requires>
      <requires>ithis.ContainsVertex(e.Target)</requires>
      <ensures>ithis.ContainsEdge(e)</ensures>
      <ensures>ithis.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsEdge(e))</ensures>
      <ensures>ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Adds a set of edges to the graph.
            </summary>
      <param name="edges" />
      <returns>the number of edges successfully added to the graph.</returns>
      <requires>edges != null</requires>
      <requires>typeof(TEdge).IsValueType || Enumerable.All(edges, edge =&gt; edge != null)</requires>
      <requires>Enumerable.All(edges, edge =&gt;
                ithis.ContainsVertex(edge.Source) &amp;&amp;
                ithis.ContainsVertex(edge.Target)
                )</requires>
      <ensures description="all edge from edges belong to the graph">Enumerable.All(edges, edge =&gt; ithis.ContainsEdge(edge))</ensures>
      <ensures>
                Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(edges, edge =&gt; !ithis.ContainsEdge(edge)))</ensures>
      <ensures>ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)">
      <summary>
            Removes <paramref name="edge" /> from the graph
            </summary>
      <param name="edge" />
      <returns>true if <paramref name="edge" /> was successfully removed; otherwise false.</returns>
      <requires>e != null</requires>
      <ensures>Contract.Result&lt;bool&gt;() == Contract.OldValue(ithis.ContainsEdge(e))</ensures>
      <ensures>!ithis.ContainsEdge(e)</ensures>
      <ensures>ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})">
      <summary>
            Removes all edges that match <paramref name="predicate" />.
            </summary>
      <param name="predicate">A pure delegate that takes an <typeparamref name="TEdge" /> and returns true if the edge should be removed.</param>
      <returns>the number of edges removed.</returns>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.Edges, e =&gt; predicate(e)))</ensures>
      <ensures>Enumerable.All(ithis.Edges, e =&gt; !predicate(e))</ensures>
      <ensures>ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="E:QuickGraph.IMutableEdgeListGraph`2.EdgeAdded">
      <summary>
            Raised when an edge is added to the graph.
            </summary>
    </member>
    <member name="E:QuickGraph.IMutableEdgeListGraph`2.EdgeRemoved">
      <summary>
            Raised when an edge has been removed from the graph.
            </summary>
    </member>
    <member name="T:QuickGraph.IMutableVertexSet`1">
      <summary>
            A mutable vertex set
            </summary>
      <typeparam name="TVertex" />
    </member>
    <member name="T:QuickGraph.IUndirectedGraph`2">
      <summary>
            An undirected graph
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="T:QuickGraph.IMutableVertexAndEdgeSet`2">
      <summary>
            A mutable vertex and edge set
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)">
      <summary>
            Adds the vertices and edge to the graph.
            </summary>
      <param name="edge" />
      <returns>true if the edge was added, otherwise false.</returns>
      <requires>edge != null</requires>
      <ensures>ithis.ContainsEdge(edge)</ensures>
      <ensures>ithis.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsEdge(edge))</ensures>
      <ensures>ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Adds a set of edges (and it's vertices if necessary)
            </summary>
      <param name="edges" />
      <returns>the number of edges added.</returns>
      <requires>edges != null</requires>
      <requires>typeof(TEdge).IsValueType || Enumerable.All(edges, edge =&gt; edge != null)</requires>
      <ensures>ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="T:QuickGraph.IImplicitGraph`2">
      <summary>
            A implicit directed graph datastructure
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
    </member>
    <member name="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)">
      <summary>
            Determines whether there are out-edges associated to <paramref name="v" />.
            </summary>
      <param name="v">The vertex.</param>
      <returns>
        <c>true</c> if <paramref name="v" /> has no out-edges; otherwise, <c>false</c>.
            </returns>
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>Contract.Result&lt;bool&gt;() == (ithis.OutDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)">
      <summary>
            Gets the count of out-edges of <paramref name="v" /></summary>
      <param name="v">The vertex.</param>
      <returns>The count of out-edges of <paramref name="v" /></returns>
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>Contract.Result&lt;int&gt;() == Enumerable.Count&lt;TEdge&gt;(ithis.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)">
      <summary>
            Gets the out-edges of <paramref name="v" />.
            </summary>
      <param name="v">The vertex.</param>
      <returns>An enumeration of the out-edges of <paramref name="v" />.</returns>
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures>Enumerable.All(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e.Source.Equals(v))</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <summary>
            Tries to get the out-edges of <paramref name="v" /></summary>
      <param name="v" />
      <param name="edges" />
      <returns />
      <pure />
      <requires>v != null</requires>
      <ensures>!Contract.Result&lt;bool&gt;() || 
                (Contract.ValueAtReturn(out edges) != null &amp;&amp; 
                 Enumerable.All(Contract.ValueAtReturn(out edges), e =&gt; e.Source.Equals(v)))</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)">
      <summary>
            Gets the out-edge of <paramref name="v" /> at position <paramref name="index" />.
            </summary>
      <param name="v">The vertex.</param>
      <param name="index">The index.</param>
      <returns>The out-edge at position <paramref name="index" /></returns>
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <requires>index &gt;= 0 &amp;&amp; index &lt; ithis.OutDegree(v)</requires>
      <ensures>
                Enumerable.ElementAt(ithis.OutEdges(v), index).Equals(Contract.Result&lt;TEdge&gt;())</ensures>
    </member>
    <member name="T:QuickGraph.SEquatableUndirectedEdge`1">
      <summary>
            An struct based <see cref="T:QuickGraph.IEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
    </member>
    <member name="T:QuickGraph.IUndirectedEdge`1">
      <summary>
            An undirected edge. 
            </summary>
      <remarks>
            Invariant: source must be less or equal to target (using the default comparer)
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
    </member>
    <member name="T:QuickGraph.IEdge`1">
      <summary>
            A directed edge
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
    </member>
    <member name="P:QuickGraph.IEdge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <getter>
        <ensures>Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.IEdge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <getter>
        <ensures>Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.SEquatableUndirectedEdge`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.SEdge`1" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <requires>source != null</requires>
      <requires>target != null</requires>
      <requires>Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0</requires>
      <ensures>Contract.ValueAtReturn(out this).Source.Equals(source)</ensures>
      <ensures>Contract.ValueAtReturn(out this).Target.Equals(target)</ensures>
    </member>
    <member name="M:QuickGraph.SEquatableUndirectedEdge`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.SEquatableUndirectedEdge`1.Equals(QuickGraph.SEquatableUndirectedEdge{`0})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <ensures>
                Contract.Result&lt;bool&gt;() ==
                (this.Source.Equals(other.Source) &amp;&amp;
                this.Target.Equals(other.Target))</ensures>
    </member>
    <member name="M:QuickGraph.SEquatableUndirectedEdge`1.Equals(System.Object)">
      <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
      <param name="obj">Another object to compare to.</param>
      <returns>
            true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
    </member>
    <member name="M:QuickGraph.SEquatableUndirectedEdge`1.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
    </member>
    <member name="P:QuickGraph.SEquatableUndirectedEdge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.SEquatableUndirectedEdge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:QuickGraph.DelegateImplicitUndirectedGraph`2">
      <summary>
            A functional implicit undirected graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.Services.IService">
      <summary>
            Interface implemented by graph services
            </summary>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.EdgeDepthFirstSearchAlgorithm`2">
      <summary>
            A edge depth first search algorithm for directed graphs
            </summary>
      <remarks>
            This is a variant of the classic DFS algorithm where the
            edges are color marked instead of the vertices.
            </remarks>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmBase`1.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,`0)">
      <summary>
            Creates a new algorithm with an (optional) host.
            </summary>
      <param name="host">if null, host is set to the this reference</param>
      <param name="visitedGraph" />
      <requires>visitedGraph != null</requires>
    </member>
    <member name="T:QuickGraph.SReversedEdge`2">
      <summary>
            A reversed edge
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.IVertexListGraph`2">
      <summary>
            A directed graph datastructure where out-edges can be traversed,
            i.e. a vertex set + implicit graph.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
    </member>
    <member name="T:QuickGraph.SUndirectedTaggedEdge`2">
      <summary>
            An struct based <see cref="T:QuickGraph.IUndirectedEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">type of the vertex.</typeparam>
      <typeparam name="TTag">type of the tag</typeparam>
    </member>
    <member name="T:QuickGraph.ITagged`1">
      <summary>
            An instance holding a tag
            </summary>
      <typeparam name="TTag" />
    </member>
    <member name="P:QuickGraph.ITagged`1.Tag">
      <summary>
            Gets or sets the tag
            </summary>
    </member>
    <member name="E:QuickGraph.ITagged`1.TagChanged">
      <summary>
            Raised when the tag is changed
            </summary>
    </member>
    <member name="M:QuickGraph.SUndirectedTaggedEdge`2.#ctor(`0,`0,`1)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.SUndirectedTaggedEdge`2" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <param name="tag">The tag.</param>
      <requires>source != null</requires>
      <requires>target != null</requires>
      <requires>Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0</requires>
      <ensures>Contract.ValueAtReturn(out this).Source.Equals(source)</ensures>
      <ensures>Contract.ValueAtReturn(out this).Target.Equals(target)</ensures>
    </member>
    <member name="M:QuickGraph.SUndirectedTaggedEdge`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:QuickGraph.SUndirectedTaggedEdge`2.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.SUndirectedTaggedEdge`2.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:QuickGraph.Collections.IDisjointSet`1">
      <summary>
            A disjoint-set data structure
            </summary>
      <typeparam name="T" />
    </member>
    <member name="M:QuickGraph.Collections.IDisjointSet`1.MakeSet(`0)">
      <summary>
            Creates a new set for the value
            </summary>
      <param name="value" />
      <requires>value != null</requires>
      <requires>!ithis.Contains(value)</requires>
      <ensures>ithis.Contains(value)</ensures>
      <ensures>ithis.SetCount == Contract.OldValue(ithis.SetCount) + 1</ensures>
      <ensures>ithis.ElementCount == Contract.OldValue(ithis.ElementCount) + 1</ensures>
    </member>
    <member name="M:QuickGraph.Collections.IDisjointSet`1.FindSet(`0)">
      <summary>
            Finds the set containing the value
            </summary>
      <param name="value" />
      <returns />
      <requires>value != null</requires>
      <requires>ithis.Contains(value)</requires>
    </member>
    <member name="M:QuickGraph.Collections.IDisjointSet`1.AreInSameSet(`0,`0)">
      <summary>
            Gets a value indicating if left and right are contained in the same set
            </summary>
      <param name="left" />
      <param name="right" />
      <returns />
      <requires>left != null</requires>
      <requires>right != null</requires>
      <requires>ithis.Contains(left)</requires>
      <requires>ithis.Contains(right)</requires>
    </member>
    <member name="M:QuickGraph.Collections.IDisjointSet`1.Union(`0,`0)">
      <summary>
            Merges the sets from the two values
            </summary>
      <param name="left" />
      <param name="right" />
      <returns>true if left and right were unioned, false if they already belong to the same set</returns>
      <requires>left != null</requires>
      <requires>ithis.Contains(left)</requires>
      <requires>right != null</requires>
      <requires>ithis.Contains(right)</requires>
    </member>
    <member name="M:QuickGraph.Collections.IDisjointSet`1.Contains(`0)">
      <summary>
            Gets a value indicating whether the value is in the data structure
            </summary>
      <param name="value" />
      <returns />
      <pure />
    </member>
    <member name="P:QuickGraph.Collections.IDisjointSet`1.SetCount">
      <summary>
            Gets the current number of sets
            </summary>
    </member>
    <member name="P:QuickGraph.Collections.IDisjointSet`1.ElementCount">
      <summary>
            Gets the current number of elements.
            </summary>
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.UndirectedDijkstraShortestPathAlgorithm`2">
      <summary>
            A single-source shortest path algorithm for undirected graph
            with positive distance.
            </summary>
      <reference-ref idref="lawler01combinatorial" />
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedShortestPathAlgorithmBase`2.OnTreeEdge(`1,System.Boolean)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.UndirectedShortestPathAlgorithmBase`2.TreeEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
      <param name="reversed" />
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.UndirectedShortestPathAlgorithmBase`2.TreeEdge">
      <summary>
            Invoked when the distance label for the target vertex is decreased. 
            The edge that participated in the last relaxation for vertex v is 
            an edge in the shortest paths tree.
            </summary>
    </member>
    <member name="T:QuickGraph.Algorithms.IDistanceRecorderAlgorithm`2">
      <summary>
            An algorithm that exposes events to compute a distance map between vertices
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.AStarShortestPathAlgorithm`2">
      <summary>
            A* single-source shortest path algorithm for directed graph
            with positive distance.
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="lawler01combinatorial" />
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.ShortestPathAlgorithmBase`3.OnTreeEdge(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.ShortestPathAlgorithmBase`3.TreeEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.ShortestPathAlgorithmBase`3.TreeEdge">
      <summary>
            Invoked when the distance label for the target vertex is decreased. 
            The edge that participated in the last relaxation for vertex v is 
            an edge in the shortest paths tree.
            </summary>
    </member>
    <member name="T:QuickGraph.Algorithms.RandomWalks.CyclePoppingRandomTreeAlgorithm`2">
      <summary>
            Wilson-Propp Cycle-Popping Algorithm for Random Tree Generation.
            </summary>
    </member>
    <member name="P:QuickGraph.Algorithms.RandomWalks.CyclePoppingRandomTreeAlgorithm`2.Rnd">
      <summary>
            Gets or sets the random number generator used in <c>RandomTree</c>.
            </summary>
      <value>
        <see cref="T:System.Random" /> number generator
            </value>
      <setter>
        <requires>value != null</requires>
      </setter>
    </member>
    <member name="T:QuickGraph.SEdge`1">
      <summary>
            An struct based <see cref="T:QuickGraph.IEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
    </member>
    <member name="M:QuickGraph.SEdge`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.SEdge`1" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <requires>source != null</requires>
      <requires>target != null</requires>
      <ensures>Contract.ValueAtReturn(out this).Source.Equals(source)</ensures>
      <ensures>Contract.ValueAtReturn(out this).Target.Equals(target)</ensures>
    </member>
    <member name="M:QuickGraph.SEdge`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:QuickGraph.SEdge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.SEdge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:QuickGraph.IMutableVertexListGraph`2">
      <summary>
            A mutable vertex list graph
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="T:QuickGraph.IMutableIncidenceGraph`2">
      <summary>
            A mutable incidence graph
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <summary>
            Removes all out edges of <paramref name="v" />
            where <paramref name="predicate" /> evalutes to true.
            </summary>
      <param name="v" />
      <param name="predicate" />
      <returns />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.OutEdges(v), ve =&gt; predicate(ve)))</ensures>
      <ensures>Enumerable.All(ithis.OutEdges(v), ve =&gt; !predicate(ve))</ensures>
    </member>
    <member name="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)">
      <summary>
            Trims the out edges of vertex <paramref name="v" /></summary>
      <param name="v" />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>ithis.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.IMutableIncidenceGraph`2.TrimEdgeExcess">
      <summary>
            Trims excess storage allocated for edges
            </summary>
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.EdgeRecorderObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.IObserver`1">
      <summary>
            An algorithm observer
            </summary>
      <typeparam name="TAlgorithm">type of the algorithm</typeparam>
      <reference-ref id="gof02designpatterns" />
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)">
      <summary>
            Attaches to the algorithm events
            and returns a disposable object that can be used
            to detach from the events
            </summary>
      <param name="algorithm" />
      <returns />
      <requires>algorithm != null</requires>
      <ensures>Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="T:QuickGraph.Algorithms.MaximumFlow.EdmondsKarpMaximumFlowAlgorithm`2">
      <summary>
            Edmond and Karp maximum flow algorithm
            for directed graph with positive capacities and
            flows.
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.MaximumFlow.MaximumFlowAlgorithm`2">
      <summary>
            Abstract base class for maximum flow algorithms.
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.EdmondsKarpMaximumFlowAlgorithm`2.InternalCompute">
      <summary>
            Computes the maximum flow between Source and Sink.
            </summary>
      <returns />
    </member>
    <member name="T:QuickGraph.Edge`1">
      <summary>
            The default <see cref="T:QuickGraph.IEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
    </member>
    <member name="M:QuickGraph.Edge`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.Edge`1" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <requires>source != null</requires>
      <requires>target != null</requires>
      <ensures>this.Source.Equals(source)</ensures>
      <ensures>this.Target.Equals(target)</ensures>
    </member>
    <member name="M:QuickGraph.Edge`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:QuickGraph.Edge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Edge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:QuickGraph.AdjacencyGraph`2">
      <summary>
            A mutable directed graph data structure efficient for sparse
            graph representation where out-edge need to be enumerated only.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <invariant>this.edgeCount &gt;= 0</invariant>
    </member>
    <member name="T:QuickGraph.IVertexAndEdgeListGraph`2">
      <summary>
            A directed graph where vertices and edges can be enumerated efficiently.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.IEdgeListAndIncidenceGraph`2">
      <summary>
            An incidence graph whose edges can be enumerated
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.IMutableVertexAndEdgeListGraph`2">
      <summary>
            A mutable vertex and edge list graph
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Adds a range of edges to the graph
            </summary>
      <param name="edges" />
      <returns>the count edges that were added</returns>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet">typeof(TEdge).IsValueType || Enumerable.All(edges, edge =&gt; edge != null)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.AddEdge(`1)">
      <summary>
            Adds the edge to the graph
            </summary>
      <param name="e">the edge to add</param>
      <returns>true if the edge was added; false if it was already part of the graph</returns>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">e != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsVertex(e.Source)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsVertex(e.Target)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsEdge(e)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsEdge(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.IsEdgesEmpty">
      <summary>
            Gets a value indicating whether this instance is edges empty.
            </summary>
      <value>
        <c>true</c> if this instance is edges empty; otherwise, <c>false</c>.
            </value>
      <getter>
        <pure />
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.EdgeCount">
      <summary>
            Gets the edge count.
            </summary>
      <value>The edge count.</value>
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.Edges">
      <summary>
            Gets the edges.
            </summary>
      <value>The edges.</value>
      <getter>
        <pure />
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="T:QuickGraph.IMutableBidirectionalGraph`2">
      <summary>
            A mutable bidirectional directed graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.IBidirectionalGraph`2">
      <summary>
            A directed graph datastructure that is efficient
            to traverse both in and out edges.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
    </member>
    <member name="T:QuickGraph.IBidirectionalIncidenceGraph`2">
      <summary>
            A directed graph datastructure that is efficient
            to traverse both in and out edges.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
    </member>
    <member name="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)">
      <summary>
            Determines whether <paramref name="v" /> has no in-edges.
            </summary>
      <param name="v">The vertex</param>
      <returns>
        <c>true</c> if <paramref name="v" /> has no in-edges; otherwise, <c>false</c>.
            </returns>
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>Contract.Result&lt;bool&gt;() == (ithis.InDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)">
      <summary>
            Gets the number of in-edges of <paramref name="v" /></summary>
      <param name="v">The vertex.</param>
      <returns>The number of in-edges pointing towards <paramref name="v" /></returns>
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)">
      <summary>
            Gets the collection of in-edges of <paramref name="v" />.
            </summary>
      <param name="v">The vertex</param>
      <returns>The collection of in-edges of <paramref name="v" /></returns>
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures>Enumerable.All(
                Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), 
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <summary>
            Tries to get the in-edges of <paramref name="v" /></summary>
      <param name="v" />
      <param name="edges" />
      <returns />
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>Contract.Result&lt;bool&gt;() == ithis.ContainsVertex(v)</ensures>
      <ensures>!Contract.Result&lt;bool&gt;() || Contract.ValueAtReturn(out edges) != null</ensures>
      <ensures>!Contract.Result&lt;bool&gt;() || 
                Enumerable.All(
                Contract.ValueAtReturn&lt;IEnumerable&lt;TEdge&gt;&gt;(out edges),
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)">
      <summary>
            Gets the in-edge at location <paramref name="index" />.
            </summary>
      <param name="v">The vertex.</param>
      <param name="index">The index.</param>
      <returns />
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <requires>index &gt;= 0 &amp;&amp; index &lt; ithis.InDegree(v)</requires>
      <ensures>Contract.Result&lt;TEdge&gt;().Equals(Enumerable.ElementAt(ithis.InEdges(v), index))</ensures>
    </member>
    <member name="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)">
      <summary>
            Gets the degree of <paramref name="v" />, i.e.
            the sum of the out-degree and in-degree of <paramref name="v" />.
            </summary>
      <param name="v">The vertex</param>
      <returns>The sum of OutDegree and InDegree of <paramref name="v" /></returns>
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>Contract.Result&lt;int&gt;() == ithis.InDegree(v) + ithis.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <summary>
            Removes in-edges of <paramref name="v" /> that match
            predicate <paramref name="edgePredicate" />.
            </summary>
      <param name="v" />
      <param name="edgePredicate" />
      <returns>Number of edges removed</returns>
      <requires>v != null</requires>
      <requires>predicate != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>ithis.ContainsVertex(v)</ensures>
      <ensures>Enumerable.All(ithis.InEdges(v), e =&gt; predicate(e))</ensures>
      <ensures>Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.InEdges(v), e =&gt; predicate(e)))</ensures>
      <ensures>ithis.InDegree(v) == Contract.OldValue(ithis.InDegree(v)) - Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.IMutableBidirectionalGraph`2.ClearInEdges(`0)">
      <summary>
            Clears in-edges of <paramref name="v" /></summary>
      <param name="v" />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - Contract.OldValue(ithis.InDegree(v))</ensures>
      <ensures>ithis.InDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.IMutableBidirectionalGraph`2.ClearEdges(`0)">
      <summary>
            Clears in-edges and out-edges of <paramref name="v" /></summary>
      <param name="v" />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>!ithis.ContainsVertex(v)</ensures>
    </member>
    <member name="T:QuickGraph.SEquatableEdge`1">
      <summary>
            An struct based <see cref="T:QuickGraph.IEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
    </member>
    <member name="M:QuickGraph.SEquatableEdge`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.SEdge`1" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <requires>source != null</requires>
      <requires>target != null</requires>
      <ensures>Contract.ValueAtReturn(out this).Source.Equals(source)</ensures>
      <ensures>Contract.ValueAtReturn(out this).Target.Equals(target)</ensures>
    </member>
    <member name="M:QuickGraph.SEquatableEdge`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.SEquatableEdge`1.Equals(QuickGraph.SEquatableEdge{`0})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <ensures>
                Contract.Result&lt;bool&gt;() ==
                (this.Source.Equals(other.Source) &amp;&amp;
                this.Target.Equals(other.Target))</ensures>
    </member>
    <member name="M:QuickGraph.SEquatableEdge`1.Equals(System.Object)">
      <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
      <param name="obj">Another object to compare to.</param>
      <returns>
            true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
    </member>
    <member name="M:QuickGraph.SEquatableEdge`1.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
    </member>
    <member name="P:QuickGraph.SEquatableEdge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.SEquatableEdge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:QuickGraph.Collections.IVertexEdgeDictionary`2">
      <summary>
            A dictionary of vertices to a list of edges
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="M:QuickGraph.Collections.IVertexEdgeDictionary`2.Clone">
      <summary>
            Gets a clone of the dictionary. The vertices and edges are not cloned.
            </summary>
      <returns />
      <ensures>Contract.Result&lt;IVertexEdgeDictionary&lt;TVertex, TEdge&gt;&gt;() != null</ensures>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2">
      <summary>
            A edge depth first search algorithm for implicit directed graphs
            </summary>
      <remarks>
            This is a variant of the classic DFS where the edges are color
            marked.
            </remarks>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnStartVertex(`0)">
      <summary>
            Triggers the StartVertex event.
            </summary>
      <param name="v" />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnStartEdge(`1)">
      <summary>
            Triggers the StartEdge event.
            </summary>
      <param name="e" />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnDiscoverTreeEdge(`1,`1)">
      <summary>
            Triggers DiscoverEdge event
            </summary>
      <param name="se" />
      <param name="e" />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnTreeEdge(`1)">
      <summary>
            Triggers the TreeEdge event.
            </summary>
      <param name="e" />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnBackEdge(`1)">
      <summary>
            Triggers the BackEdge event.
            </summary>
      <param name="e" />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnForwardOrCrossEdge(`1)">
      <summary>
            Triggers the ForwardOrCrossEdge event.
            </summary>
      <param name="e" />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnFinishEdge(`1)">
      <summary>
            Triggers the ForwardOrCrossEdge event.
            </summary>
      <param name="e" />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.Visit(`1,System.Int32)">
      <summary>
            Does a depth first search on the vertex u
            </summary>
      <param name="se">edge to explore</param>
      <param name="depth">current exploration depth</param>
      <exception cref="T:System.ArgumentNullException">se cannot be null</exception>
      <requires>se != null</requires>
      <requires>depth &gt;= 0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.Initialize">
      <summary>
            Initializes the algorithm before computation.
            </summary>
    </member>
    <member name="P:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.EdgeColors">
      <summary>
            Gets the vertex color map
            </summary>
      <value>
            Vertex color (<see cref="T:QuickGraph.GraphColor" />) dictionary
            </value>
    </member>
    <member name="P:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.MaxDepth">
      <summary>
            Gets or sets the maximum exploration depth, from
            the start vertex.
            </summary>
      <remarks>
            Defaulted at <c>int.MaxValue</c>.
            </remarks>
      <value>
            Maximum exploration depth.
            </value>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.StartVertex">
      <summary>
            Invoked on the source vertex once before the start of the search. 
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.StartEdge">
      <summary>
            Invoked on the first edge of a test case
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.DiscoverTreeEdge">
      <summary />
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.TreeEdge">
      <summary>
            Invoked on each edge as it becomes a member of the edges that form 
            the search tree. If you wish to record predecessors, do so at this 
            event point. 
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.BackEdge">
      <summary>
            Invoked on the back edges in the graph. 
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.ForwardOrCrossEdge">
      <summary>
            Invoked on forward or cross edges in the graph. 
            (In an undirected graph this method is never called.) 
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.FinishEdge">
      <summary>
            Invoked on a edge after all of its out edges have been added to 
            the search tree and all of the adjacent vertices have been 
            discovered (but before their out-edges have been examined). 
            </summary>
    </member>
    <member name="T:QuickGraph.CreateEdgeDelegate`2">
      <summary>
            An edge factory delegate
            </summary>
    </member>
    <member name="T:QuickGraph.GraphExtensions">
      <summary>
            Extension methods for populating graph datastructures
            </summary>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToVertexAndEdgeListGraph``3(System.Collections.Generic.IDictionary{``0,``2})">
      <summary>
            Wraps a dictionary into a vertex and edge list graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <typeparam name="TValue" />
      <param name="dictionary" />
      <returns />
      <requires>dictionary != null</requires>
      <requires>Enumerable.All(dictionary.Values, v =&gt; v != null)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToVertexAndEdgeListGraph``3(System.Collections.Generic.IDictionary{``0,``2},System.Func{System.Collections.Generic.KeyValuePair{``0,``2},System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Wraps a dictionary into a vertex and edge list graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <typeparam name="TValue" />
      <param name="dictionary" />
      <param name="keyValueToOutEdges" />
      <returns />
      <requires>dictionary != null</requires>
      <requires>keyValueToOutEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateIncidenceGraph``2(QuickGraph.TryFunc{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="tryGetOutEdges" />
      <returns />
      <requires>tryGetOutEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateBidirectionalIncidenceGraph``2(QuickGraph.TryFunc{``0,System.Collections.Generic.IEnumerable{``1}},QuickGraph.TryFunc{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="tryGetOutEdges" />
      <param name="tryGetInEdges" />
      <returns />
      <requires>tryGetOutEdges != null</requires>
      <requires>tryGetInEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateIncidenceGraph``2(System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="getOutEdges" />
      <returns />
      <requires>getOutEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToTryFunc``2(System.Func{``0,``1})">
      <summary>
            Converts a Func that returns a reference type into a tryfunc
            </summary>
      <typeparam name="T" />
      <typeparam name="TResult" />
      <param name="func" />
      <returns />
      <requires>func != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateVertexAndEdgeListGraph``2(System.Collections.Generic.IEnumerable{``0},QuickGraph.TryFunc{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <param name="vertices" />
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="tryGetOutEdges" />
      <returns />
      <requires>vertices != null</requires>
      <requires>tryGetOutEdges != null</requires>
      <requires>Enumerable.All(vertices, v =&gt;
            {
                IEnumerable&lt;TEdge&gt; edges;
                return tryGetOutEdges(v, out edges);
            })</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateVertexAndEdgeListGraph``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <param name="vertices" />
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="getOutEdges" />
      <returns />
      <requires>vertices != null</requires>
      <requires>getOutEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateUndirectedGraph``3(System.Collections.Generic.IDictionary{``0,``2})">
      <summary>
            Wraps a dictionary into an undirected list graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <typeparam name="TValue" />
      <param name="dictionary" />
      <returns />
      <requires>dictionary != null</requires>
      <requires>Enumerable.All(dictionary.Values, v =&gt; v != null)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateUndirectedGraph``3(System.Collections.Generic.IDictionary{``0,``2},System.Func{System.Collections.Generic.KeyValuePair{``0,``2},System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Wraps a dictionary into an undirected graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <typeparam name="TValue" />
      <param name="dictionary" />
      <param name="keyValueToOutEdges" />
      <returns />
      <requires>dictionary != null</requires>
      <requires>keyValueToOutEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateUndirectedGraph``2(System.Collections.Generic.IEnumerable{``0},QuickGraph.TryFunc{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <param name="vertices" />
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="tryGetAdjacentEdges" />
      <returns />
      <requires>vertices != null</requires>
      <requires>tryGetAdjacentEdges != null</requires>
      <requires>Enumerable.All(vertices, v =&gt;
            {
                IEnumerable&lt;TEdge&gt; edges;
                return tryGetAdjacentEdges(v, out edges);
            })</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateUndirectedGraph``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <param name="vertices" />
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="getAdjacentEdges" />
      <returns />
      <requires>vertices != null</requires>
      <requires>getAdjacentEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToAdjacencyGraph``1(``0[][])">
      <summary>
            Converts a jagged array of sources and targets into a graph
            </summary>
      <typeparam name="TVertex" />
      <param name="edges" />
      <returns />
      <requires>edges != null</requires>
      <requires>edges.Length == 2</requires>
      <requires>edges[0] != null</requires>
      <requires>edges[1] != null</requires>
      <requires>edges[0].Length == edges[1].Length</requires>
      <ensures>Contract.Result&lt;AdjacencyGraph&lt;TVertex, SEquatableEdge&lt;TVertex&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToArrayAdjacencyGraph``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <summary>
            Creates an immutable array adjacency graph from the input graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="graph" />
      <returns />
      <requires>graph != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToArrayBidirectionalGraph``2(QuickGraph.IBidirectionalGraph{``0,``1})">
      <summary>
            Creates an immutable array bidirectional graph from the input graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="graph" />
      <returns />
      <requires>graph != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToArrayUndirectedGraph``2(QuickGraph.IUndirectedGraph{``0,``1})">
      <summary>
            Creates an immutable array undirected graph from the input graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="graph" />
      <returns />
      <requires>graph != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToBidirectionalGraph``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <summary>
            Wraps a adjacency graph (out-edge only) into a bidirectional graph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="graph" />
      <returns />
      <requires>graph != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToUndirectedGraph``2(System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Converts a sequence of edges into an undirected graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edges" />
      <returns />
      <requires>edges != null</requires>
      <requires>Enumerable.All(edges, e =&gt; e != null)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToUndirectedGraph``2(System.Collections.Generic.IEnumerable{``1},System.Boolean)">
      <summary>
            Converts a sequence of edges into an undirected graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edges" />
      <param name="allowParralelEdges" />
      <returns />
      <requires>edges != null</requires>
      <requires>Enumerable.All(edges, e =&gt; e != null)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToBidirectionalGraph``2(System.Collections.Generic.IEnumerable{``1},System.Boolean)">
      <summary>
            Converts a set of edges into a bidirectional graph.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="edges">The edges.</param>
      <param name="allowParallelEdges">if set to <c>true</c>, the graph allows parallel edges.</param>
      <returns />
      <requires>edges != null</requires>
      <requires>EnumerableContract.ElementsNotNull(edges)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToBidirectionalGraph``2(System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Converts a set of edges into a bidirectional graph.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="edges">The edges.</param>
      <returns />
      <requires>edges != null</requires>
      <requires>EnumerableContract.ElementsNotNull(edges)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToAdjacencyGraph``2(System.Collections.Generic.IEnumerable{``1},System.Boolean)">
      <summary>
            Converts a set of edges into an adjacency graph.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="edges">The edges.</param>
      <param name="allowParallelEdges">if set to <c>true</c>, the graph allows parallel edges.</param>
      <returns />
      <requires>edges != null</requires>
      <requires>EnumerableContract.ElementsNotNull(edges)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToAdjacencyGraph``2(System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Converts a set of edges into an adjacency graph.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="edges">The edges.</param>
      <returns />
      <requires>edges != null</requires>
      <requires>EnumerableContract.ElementsNotNull(edges)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToAdjacencyGraph``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Boolean)">
      <summary>
            Converts a set of vertices into an adjacency graph,
            using an edge factory.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="vertices">The vertices.</param>
      <param name="outEdgesFactory">The out edges factory.</param>
      <param name="allowParallelEdges">if set to <c>true</c>, the graph allows parallel edges.</param>
      <returns />
      <requires>vertices != null</requires>
      <requires>outEdgesFactory != null</requires>
      <requires>EnumerableContract.ElementsNotNull(vertices)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToAdjacencyGraph``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Converts a set of vertices into an adjacency graph,
            using an edge factory.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="vertices">The vertices.</param>
      <param name="outEdgesFactory">The out edges factory.</param>
      <returns />
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToBidirectionalGraph``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Boolean)">
      <summary>
            Converts a set of vertices into a bidirectional graph,
            using an edge factory.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="vertices">The vertices.</param>
      <param name="outEdgesFactory">The out edges factory.</param>
      <param name="allowParallelEdges">if set to <c>true</c>, the graph allows parallel edges.</param>
      <returns />
      <requires>vertices != null</requires>
      <requires>outEdgesFactory != null</requires>
      <requires>EnumerableContract.ElementsNotNull(vertices)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToBidirectionalGraph``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Converts a set of vertices into a bidirectional graph,
            using an edge factory
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="vertices">The vertices.</param>
      <param name="outEdgesFactory">The out edges factory.</param>
      <returns />
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToAdjacencyGraph``1(System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{``0}})">
      <summary>
            Converts a sequence of vertex pairs into an adjancency graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <param name="vertexPairs" />
      <returns />
      <requires>vertexPairs != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToBidirectionalGraph``1(System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{``0}})">
      <summary>
            Converts a sequence of vertex pairs into an bidirectional graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <param name="vertexPairs" />
      <returns />
      <requires>vertexPairs != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToUndirectedGraph``1(System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{``0}})">
      <summary>
            Converts a sequence of vertex pairs into an bidirectional graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <param name="vertexPairs" />
      <returns />
      <requires>vertexPairs != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToCompressedRowGraph``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <summary>
            Creates an immutable compressed row graph representation of the visited graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <requires>visitedGraph != null</requires>
    </member>
    <member name="T:QuickGraph.Contracts.GraphContract">
      <summary>
            Debug only assertions and assumptions
            </summary>
    </member>
    <member name="T:QuickGraph.TaggedUndirectedEdge`2">
      <summary>
            A tagged undirected edge.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TTag">Type type of the tag</typeparam>
    </member>
    <member name="T:QuickGraph.UndirectedEdge`1">
      <summary>
            The default <see cref="T:QuickGraph.IUndirectedEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
    </member>
    <member name="M:QuickGraph.UndirectedEdge`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.Edge`1" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <requires>source != null</requires>
      <requires>target != null</requires>
      <requires>Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0</requires>
      <ensures>this.source.Equals(source)</ensures>
      <ensures>this.target.Equals(target)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedEdge`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:QuickGraph.UndirectedEdge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedEdge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.TaggedUndirectedEdge`2.#ctor(`0,`0,`1)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.TaggedUndirectedEdge`2" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <param name="tag">the tag</param>
    </member>
    <member name="M:QuickGraph.TaggedUndirectedEdge`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="E:QuickGraph.TaggedUndirectedEdge`2.TagChanged">
      <summary>
            Raised when the tag is changed
            </summary>
    </member>
    <member name="P:QuickGraph.TaggedUndirectedEdge`2.Tag">
      <summary>
            Gets or sets the tag
            </summary>
    </member>
    <member name="T:QuickGraph.Collections.BinaryHeap`2">
      <summary>
            Binary heap
            </summary>
      <remarks>
            Indexing rules:
            
            parent index: index ¡ 1)/2
            left child: 2 * index + 1
            right child: 2 * index + 2
            
            Reference:
            http://dotnetslackers.com/Community/files/folders/data-structures-and-algorithms/entry28722.aspx
            </remarks>
      <typeparam name="TValue">type of the value</typeparam>
      <typeparam name="TPriority">type of the priority metric</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2">
      <summary>
            Floyd-Warshall all shortest path algorith,
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.DijkstraShortestPathAlgorithm`2">
      <summary>
            Dijkstra single-source shortest path algorithm for directed graph
            with positive distance.
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="lawler01combinatorial" />
    </member>
    <member name="T:QuickGraph.Algorithms.Services.IAlgorithmServices">
      <summary>
            Common services available to algorithm instances
            </summary>
    </member>
    <member name="P:QuickGraph.Predicates.ReversedResidualEdgePredicate`2.ResidualCapacities">
      <summary>
            Residual capacities map
            </summary>
    </member>
    <member name="P:QuickGraph.Predicates.ReversedResidualEdgePredicate`2.ReversedEdges">
      <summary>
            Reversed edges map
            </summary>
    </member>
    <member name="T:QuickGraph.GraphColor">
      <summary>
            Colors used in vertex coloring algorithms
            </summary>
    </member>
    <member name="F:QuickGraph.GraphColor.White">
      <summary>
            Usually initial color,
            </summary>
    </member>
    <member name="F:QuickGraph.GraphColor.Gray">
      <summary>
            Usually intermidiate color,
            </summary>
    </member>
    <member name="F:QuickGraph.GraphColor.Black">
      <summary>
            Usually finished color
            </summary>
    </member>
    <member name="T:QuickGraph.BidirectionalGraph`2">
      <summary>
            A mutable directed graph data structure efficient for sparse
            graph representation where out-edge and in-edges need to be enumerated. Requires
            twice as much memory as the adjacency graph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.DelegateIncidenceGraph`2">
      <summary>
            A delegate-based incidence graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.DelegateImplicitGraph`2">
      <summary>
            A delegate-based implicit graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Collections.HeapDirection">
      <summary>
            Specifies the order in which a Heap will Dequeue items.
            </summary>
    </member>
    <member name="F:QuickGraph.Collections.HeapDirection.Increasing">
      <summary>
            Items are Dequeued in Increasing order from least to greatest.
            </summary>
    </member>
    <member name="F:QuickGraph.Collections.HeapDirection.Decreasing">
      <summary>
            Items are Dequeued in Decreasing order, from greatest to least.
            </summary>
    </member>
    <member name="M:QuickGraph.Collections.LambdaHelpers.ForEach``1(System.Collections.Generic.IList{``0},System.Action{``0})">
      <summary>
            Performs an action on each item in a list, used to shortcut a "foreach" loop
            </summary>
      <typeparam name="T">Type contained in List</typeparam>
      <param name="collection">List to enumerate over</param>
      <param name="action">Lambda Function to be performed on all elements in List</param>
    </member>
    <member name="M:QuickGraph.Collections.LambdaHelpers.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Performs an action on each item in a list, used to shortcut a "foreach" loop
            </summary>
      <typeparam name="T">Type contained in List</typeparam>
      <param name="collection">List to enumerate over</param>
      <param name="action">Lambda Function to be performed on all elements in List</param>
    </member>
    <member name="F:QuickGraph.Collections.FibonacciHeapCell`2.Marked">
      <summary>
            Determines of a Node has had a child cut from it before
            </summary>
    </member>
    <member name="F:QuickGraph.Collections.FibonacciHeapCell`2.Degree">
      <summary>
            Determines the depth of a node
            </summary>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.UpdateNodesDegree(QuickGraph.Collections.FibonacciHeapCell{`0,`1})">
      <summary>
            Updates the degree of a node, cascading to update the degree of the
            parents if nessecary
            </summary>
      <param name="parentNode" />
      <requires>parentNode != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.UpdateNext">
      <summary>
            Updates the Next pointer, maintaining the heap
            by folding duplicate heap degrees into eachother
            Takes O(lg(N)) time amortized
            </summary>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.ReduceNodes(QuickGraph.Collections.FibonacciHeapCell{`0,`1},QuickGraph.Collections.FibonacciHeapCell{`0,`1})">
      <summary>
            Given two nodes, adds the child node as a child of the parent node
            </summary>
      <param name="parentNode" />
      <param name="childNode" />
      <requires>parentNode != null</requires>
      <requires>childNode != null</requires>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.UndirectedBreadthFirstSearchAlgorithm`2">
      <summary>
            A breath first search algorithm for undirected graphs
            </summary>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="T:QuickGraph.ICloneableEdge`2">
      <summary>
            A cloneable edge
            </summary>
      <typeparam name="TVertex">type of the vertex</typeparam>
      <typeparam name="TEdge">type of the edge</typeparam>
    </member>
    <member name="M:QuickGraph.ICloneableEdge`2.Clone(`0,`0)">
      <summary>
            Clones the edge content to a different pair of <paramref name="source" />
            and <paramref name="target" /> vertices
            </summary>
      <param name="source">The source vertex of the new edge</param>
      <param name="target">The target vertex of the new edge</param>
      <returns>A clone of the edge with new source and target vertices</returns>
      <requires>source != null</requires>
      <requires>target != null</requires>
      <ensures>Contract.Result&lt;TEdge&gt;() != null</ensures>
      <ensures>Contract.Result&lt;TEdge&gt;().Source.Equals(source)</ensures>
      <ensures>Contract.Result&lt;TEdge&gt;().Target.Equals(target)</ensures>
    </member>
    <member name="M:QuickGraph.IHierarchy`2.GetParent(`0)">
      <summary>
            Gets the parent <typeparamref name="TVertex" /> of <paramref name="vertex" /></summary>
      <param name="vertex" />
      <returns />
      <exception cref="T:System.ArgumentException">
        <paramref name="vertex" /> is the root of the graph.
            </exception>
    </member>
    <member name="M:QuickGraph.IHierarchy`2.GetParentEdge(`0)">
      <summary>
            Gets the parent <typeparamref name="TEdge" /> of <paramref name="vertex" /></summary>
      <param name="vertex" />
      <returns />
      <exception cref="T:System.ArgumentException">
        <paramref name="vertex" /> is the root of the graph.
            </exception>
    </member>
    <member name="M:QuickGraph.IHierarchy`2.IsCrossEdge(`1)">
      <summary>
            Gets a value indicating if <paramref name="edge" /> is 
            a cross edge.
            </summary>
      <param name="edge" />
      <returns />
    </member>
    <member name="M:QuickGraph.IHierarchy`2.IsRealEdge(`1)">
      <summary>
            Gets a value indicating whether <paramref name="edge" /> 
            exists really or is just an induced edge.
            </summary>
      <param name="edge" />
      <returns />
    </member>
    <member name="M:QuickGraph.IHierarchy`2.IsPredecessorOf(`0,`0)">
      <summary>
            Gets a value indicating if <paramref name="source" />
            is a predecessor of <paramref name="target" /></summary>
      <param name="source" />
      <param name="target" />
      <returns>
            true if <paramref name="source" /> is a predecessor of
            <paramref name="target" /></returns>
    </member>
    <member name="M:QuickGraph.IHierarchy`2.InducedEdgeCount(`0,`0)">
      <summary>
            Gets the number of edges between <paramref name="source" />
            and <paramref name="target" />. 
            </summary>
      <param name="source" />
      <param name="target" />
      <returns />
      <exception cref="T:System.ArgumentException">
        <paramref name="source" /> is a predecessor of <paramref name="target" />
            or the otherway round.
            </exception>
    </member>
    <member name="M:QuickGraph.IHierarchy`2.IsInnerNode(`0)">
      <summary>
            Gets a value indicating if <paramref name="vertex" /> is 
            inner node or a leaf.
            </summary>
      <param name="vertex" />
      <returns>
            true if not a leaf
            </returns>
    </member>
    <member name="M:QuickGraph.IHierarchy`2.ChildrenEdges(`0)">
      <summary>
            Gets the collection of children <typeparamref name="TEdge" />
            from <paramref name="vertex" /></summary>
      <param name="vertex" />
      <returns />
    </member>
    <member name="M:QuickGraph.IHierarchy`2.ChildrenVertices(`0)">
      <summary>
            Gets the collection of children <typeparamref name="TVertex" />
            from <paramref name="vertex" /></summary>
      <param name="vertex" />
      <returns />
    </member>
    <member name="P:QuickGraph.IHierarchy`2.Root">
      <summary>
            Gets the roots of the hierarchy
            </summary>
    </member>
    <member name="T:System.Diagnostics.Contracts.DummyContract">
      <summary>
            Ensures that System.Diagnostics.Contracts namespace exists 
            </summary>
    </member>
    <member name="T:QuickGraph.Collections.IEdgeList`2">
      <summary>
            A cloneable list of edges
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="M:QuickGraph.Collections.IEdgeList`2.TrimExcess">
      <summary>
            Trims excess allocated space
            </summary>
    </member>
    <member name="M:QuickGraph.Collections.IEdgeList`2.Clone">
      <summary>
            Gets a clone of this list
            </summary>
      <returns />
      <ensures>Contract.Result&lt;IEdgeList&lt;TVertex, TEdge&gt;&gt;() != null</ensures>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.BidirectionalDepthFirstSearchAlgorithm`2">
      <summary>
            A depth and height first search algorithm for directed graphs
            </summary>
      <remarks>
            This is a modified version of the classic DFS algorithm
            where the search is performed both in depth and height.
            </remarks>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="T:QuickGraph.Algorithms.LengauerTarjanDominatorAlgorithm`2">
      <summary>
            Computes the dominator map of a directed graph
            </summary>
      <remarks>
            Thomas Lengauer and Robert Endre Tarjan
            A fast algorithm for finding dominators in a flowgraph
            ACM Transactions on Programming Language and Systems, 1(1):121-141, 1979. 
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.DelegateUndirectedGraph`2">
      <summary>
            A functional implicit undirected graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.CompressedSparseRowGraph`1">
      <summary>
            Directed graph representation using a Compressed Sparse Row representation
            (http://www.cs.utk.edu/~dongarra/etemplates/node373.html)
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.EdgePredecessorRecorderObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2">
      <summary>
            A depth first search algorithm for implicit directed graphs
            </summary>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnStartVertex(`0)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.StartVertex" /> event.
            </summary>
      <param name="v">vertex that raised the event</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnDiscoverVertex(`0)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.DiscoverVertex" /> event.
            </summary>
      <param name="v">vertex that raised the event</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnExamineEdge(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.ExamineEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnTreeEdge(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.TreeEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnBackEdge(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.BackEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnForwardOrCrossEdge(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.ForwardOrCrossEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnFinishVertex(`0)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.FinishVertex" /> event.
            </summary>
      <param name="v">vertex that raised the event</param>
    </member>
    <member name="P:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.VertexColors">
      <summary>
            Gets the vertex color map
            </summary>
      <value>
            Vertex color (<see cref="T:QuickGraph.GraphColor" />) dictionary
            </value>
    </member>
    <member name="P:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.MaxDepth">
      <summary>
            Gets or sets the maximum exploration depth, from
            the start vertex.
            </summary>
      <remarks>
            Defaulted at <c>int.MaxValue</c>.
            </remarks>
      <value>
            Maximum exploration depth.
            </value>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.StartVertex">
      <summary>
            Invoked on the source vertex once before the start of the search. 
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.DiscoverVertex">
      <summary>
            Invoked when a vertex is encountered for the first time. 
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.ExamineEdge">
      <summary>
            Invoked on every out-edge of each vertex after it is discovered. 
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.TreeEdge">
      <summary>
            Invoked on each edge as it becomes a member of the edges that form 
            the search tree. If you wish to record predecessors, do so at this 
            event point. 
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.BackEdge">
      <summary>
            Invoked on the back edges in the graph. 
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.ForwardOrCrossEdge">
      <summary>
            Invoked on forward or cross edges in the graph. 
            (In an undirected graph this method is never called.) 
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.FinishVertex">
      <summary>
            Invoked on a vertex after all of its out edges have been added to 
            the search tree and all of the adjacent vertices have been 
            discovered (but before their out-edges have been examined). 
            </summary>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2">
      <summary>
            A depth first search algorithm for directed graph
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.#ctor(QuickGraph.IUndirectedGraph{`0,`1})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="visitedGraph">visited graph</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.#ctor(QuickGraph.IUndirectedGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="visitedGraph">visited graph</param>
      <param name="colors">vertex color map</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IUndirectedGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="host">algorithm host</param>
      <param name="visitedGraph">visited graph</param>
      <param name="colors">vertex color map</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IUndirectedGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor},System.Func{System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`1}})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="host">algorithm host</param>
      <param name="visitedGraph">visited graph</param>
      <param name="colors">vertex color map</param>
      <param name="adjacentEdgeEnumerator">
            Delegate that takes the enumeration of out-edges and reorders
            them. All vertices passed to the method should be enumerated once and only once.
            May be null.
            </param>
      <requires>colors != null</requires>
      <requires>adjacentEdgeEnumerator != null</requires>
    </member>
    <member name="T:QuickGraph.TaggedEquatableEdge`2">
      <summary>
            An equatable, tagged, edge
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TTag" />
    </member>
    <member name="T:QuickGraph.EquatableEdge`1">
      <summary>
            An equatable edge implementation
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
    </member>
    <member name="T:QuickGraph.STaggedEquatableEdge`2">
      <summary>
            A tagged edge as value type.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TTag" />
    </member>
    <member name="M:QuickGraph.STaggedEquatableEdge`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.STaggedEquatableEdge`2.Equals(QuickGraph.STaggedEquatableEdge{`0,`1})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <ensures>
                Contract.Result&lt;bool&gt;() ==
                (this.Source.Equals(other.Source) &amp;&amp;
                this.Target.Equals(other.Target))</ensures>
    </member>
    <member name="M:QuickGraph.STaggedEquatableEdge`2.Equals(System.Object)">
      <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
      <param name="obj">Another object to compare to.</param>
      <returns>
            true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
    </member>
    <member name="M:QuickGraph.STaggedEquatableEdge`2.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
    </member>
    <member name="T:QuickGraph.DelegateBidirectionalIncidenceGraph`2">
      <summary>
            A delegate based bidirectional implicit graph
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="T:QuickGraph.ArrayUndirectedGraph`2">
      <summary>
            An immutable undirected graph data structure based on arrays.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.Clone">
      <summary>
            Returns self
            </summary>
      <returns />
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.VertexTimeStamperObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.TarjanOfflineLeastCommonAncestorAlgorithm`2">
      <summary>
            Offline least common ancestor in a rooted tre
            </summary>
      <remarks>
            Reference:
            Gabow, H. N. and Tarjan, R. E. 1983. A linear-time algorithm for a special case 
            of disjoint set union. In Proceedings of the Fifteenth Annual ACM Symposium 
            on theory of Computing STOC '83. ACM, New York, NY, 246-251. 
            DOI= http://doi.acm.org/10.1145/800061.808753 
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.DagShortestPathAlgorithm`2">
      <summary>
            A single-source shortest path algorithm for directed acyclic
            graph.
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref id="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2">
      <summary>
            Bellman Ford shortest path algorithm.
            </summary>
      <remarks>
        <para>
            The Bellman-Ford algorithm solves the single-source shortest paths 
            problem for a graph with both positive and negative edge weights. 
            </para>
        <para>
            If you only need to solve the shortest paths problem for positive 
            edge weights, Dijkstra's algorithm provides a more efficient 
            alternative. 
            </para>
        <para>
            If all the edge weights are all equal to one then breadth-first search 
            provides an even more efficient alternative. 
            </para>
      </remarks>
      <reference-ref idref="shi03datastructures" />
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.OnInitializeVertex(`0)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.InitializeVertex" /> event.
            </summary>
      <param name="v">vertex that raised the event</param>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.OnExamineEdge(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.ExamineEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.OnEdgeNotRelaxed(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.EdgeNotRelaxed" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.OnEdgeMinimized(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.EdgeMinimized" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.OnEdgeNotMinimized(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.EdgeNotMinimized" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.InternalCompute">
      <summary>
            Applies the Bellman Ford algorithm
            </summary>
      <remarks>
            Does not initialize the predecessor and distance map.
            </remarks>
    </member>
    <member name="P:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.FoundNegativeCycle">
      <summary>
            Indicates if a negative cycle was found
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.InitializeVertex">
      <summary>
            Invoked on each vertex in the graph before the start of the 
            algorithm.
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.ExamineEdge">
      <summary>
            Invoked on every edge in the graph |V| times.
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.EdgeNotRelaxed">
      <summary>
             Invoked if the distance label for the target vertex is not 
             decreased.
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.EdgeMinimized">
      <summary>
             Invoked during the second stage of the algorithm, 
             during the test of whether each edge was minimized. 
             
             If the edge is minimized then this function is invoked.
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.EdgeNotMinimized">
      <summary>
            Invoked during the second stage of the algorithm, 
            during the test of whether each edge was minimized. 
            
            If the edge was not minimized, this function is invoked. 
            This happens when there is a negative cycle in the graph. 
            </summary>
    </member>
    <member name="P:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.Predecessors">
      <summary>
            Constructed predecessor map
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Services.ICancelManager.Cancel">
      <summary>
            Requests the component to cancel its computation
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Services.ICancelManager.ResetCancel">
      <summary>
            Resets the cancel state
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Services.ICancelManager.CancelRequested">
      <summary>
            Raised when the cancel method is called
            </summary>
    </member>
    <member name="P:QuickGraph.Algorithms.Services.ICancelManager.IsCancelling">
      <summary>
            Gets a value indicating if a cancellation request is pending.
            </summary>
      <returns />
    </member>
    <member name="E:QuickGraph.Algorithms.Services.ICancelManager.CancelReseted">
      <summary>
            Raised when the cancel state has been reseted
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Services.CancelManager.ResetCancel">
      <summary>
            Resets the cancel state
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Services.CancelManager.CancelReseted">
      <summary>
            Raised when the cancel state has been reseted
            </summary>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.BestFirstFrontierSearchAlgorithm`2">
      <summary>
            Best first frontier search
            </summary>
      <remarks>
            Algorithm from Frontier Search, Korkf, Zhand, Thayer, Hohwald.
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.MaximumFlow.BipartiteToMaximumFlowGraphAugmentorAlgorithm`2">
      <summary>
            This algorithm modifies a bipartite graph into a related graph, where each Vertex in one partition is 
            connected to a newly added "SuperSource" and each Vertex in the other partition is connected to a newly added "SuperSink"
            When the maximum flow of this related graph is computed, the edges used for the flow are also those which make up
            the maximum match for the bipartite graph.
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="T:QuickGraph.EdgeFactory`2">
      <summary>
            An edge factory
            </summary>
    </member>
    <member name="T:QuickGraph.Collections.ForestDisjointSet`1">
      <summary>
            Disjoint-set implementation with path compression and union-by-rank optimizations.
            optimization
            </summary>
      <typeparam name="T" />
      <invariant>this.setCount &gt;= 0</invariant>
      <invariant>this.setCount &lt;= this.elements.Count</invariant>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.MakeSet(`0)">
      <summary>
            Adds a new set
            </summary>
      <param name="value" />
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.MakeSet(`0)" inheritedFromTypeName="IDisjointSet">value != null</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.MakeSet(`0)" inheritedFromTypeName="IDisjointSet">!ithis.Contains(value)</requires>
      <ensures inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.MakeSet(`0)" inheritedFromTypeName="IDisjointSet">ithis.Contains(value)</ensures>
      <ensures inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.MakeSet(`0)" inheritedFromTypeName="IDisjointSet">ithis.SetCount == Contract.OldValue(ithis.SetCount) + 1</ensures>
      <ensures inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.MakeSet(`0)" inheritedFromTypeName="IDisjointSet">ithis.ElementCount == Contract.OldValue(ithis.ElementCount) + 1</ensures>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.Find(QuickGraph.Collections.ForestDisjointSet{`0}.Element)">
      <summary>
            Finds the parent element, and applies path compression
            </summary>
      <param name="element" />
      <returns />
      <requires>element != null</requires>
      <ensures>Contract.Result&lt;Element&gt;() != null</ensures>
    </member>
    <member name="T:QuickGraph.ArrayAdjacencyGraph`2">
      <summary>
            An immutable directed graph data structure efficient for large sparse
            graph representation where out-edge need to be enumerated only.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.Clone">
      <summary>
            Returns self since this class is immutable
            </summary>
      <returns />
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.VertexPredecessorRecorderObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.IdentifiableEdgeFactory`2">
      <summary>
            A factory of identifiable edges.
            </summary>
    </member>
    <member name="T:QuickGraph.STaggedEdge`2">
      <summary>
            A tagged edge as value type.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TTag" />
    </member>
    <member name="M:QuickGraph.STaggedEdge`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="T:QuickGraph.ArrayBidirectionalGraph`2">
      <summary>
            An immutable directed graph data structure efficient for large sparse
            graph representation where out-edge need to be enumerated only.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.#ctor(QuickGraph.IBidirectionalGraph{`0,`1})">
      <summary>
            Constructs a new ArrayBidirectionalGraph instance from a 
            IBidirectionalGraph instance
            </summary>
      <param name="visitedGraph" />
      <requires>visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.Clone">
      <summary>
            Returns self since this class is immutable
            </summary>
      <returns />
    </member>
    <member name="T:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2">
      <summary>
            A depth first search algorithm for directed graph
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
      <invariant>this.MaxDepth &gt; 0</invariant>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.#ctor(QuickGraph.IVertexListGraph{`0,`1})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="visitedGraph">visited graph</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.#ctor(QuickGraph.IVertexListGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="visitedGraph">visited graph</param>
      <param name="colors">vertex color map</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="host">algorithm host</param>
      <param name="visitedGraph">visited graph</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="host">algorithm host</param>
      <param name="visitedGraph">visited graph</param>
      <param name="colors">vertex color map</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor},System.Func{System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`1}})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="host">algorithm host</param>
      <param name="visitedGraph">visited graph</param>
      <param name="colors">vertex color map</param>
      <param name="outEdgeEnumerator">
            Delegate that takes the enumeration of out-edges and reorders
            them. All vertices passed to the method should be enumerated once and only once.
            May be null.
            </param>
      <requires>colors != null</requires>
      <requires>outEdgeEnumerator != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IMutableVertexAndEdgeListGraph{`0,`1})">
      <summary>
            Construct an eulerian trail builder
            </summary>
      <param name="host" />
      <param name="visitedGraph" />
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.Visit">
      <summary>
            Looks for a new path to add to the current vertex.
            </summary>
      <returns>true if found a new path, false otherwize</returns>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.ComputeEulerianPathCount(QuickGraph.IVertexAndEdgeListGraph{`0,`1})">
      <summary>
            Computes the number of eulerian trail in the graph.
            </summary>
      <param name="g" />
      <returns>number of eulerian trails</returns>
      <requires>g != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.CircuitAugmentation">
      <summary>
            Merges the temporary circuit with the current circuit
            </summary>
      <returns>true if all the graph edges are in the circuit</returns>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.AddTemporaryEdges(QuickGraph.EdgeFactory{`0,`1})">
      <summary>
            Adds temporary edges to the graph to make all vertex even.
            </summary>
      <param name="edgeFactory" />
      <returns />
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.RemoveTemporaryEdges">
      <summary>
            Removes temporary edges
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.Trails">
      <summary>
            Computes the set of eulerian trails that traverse the edge set.
            </summary>
      <remarks>
            This method returns a set of disjoint eulerian trails. This set
            of trails spans the entire set of edges.
            </remarks>
      <returns>Eulerian trail set</returns>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.Trails(`0)">
      <summary>
            Computes a set of eulerian trail, starting at <paramref name="s" />
            that spans the entire graph.
            </summary>
      <remarks>
        <para>
            This method computes a set of eulerian trail starting at <paramref name="s" />
            that spans the entire graph.The algorithm outline is as follows:
            </para>
        <para>
            The algorithms iterates throught the Eulerian circuit of the augmented
            graph (the augmented graph is the graph with additional edges to make
            the number of odd vertices even).
            </para>
        <para>
            If the current edge is not temporary, it is added to the current trail.
            </para>
        <para>
            If the current edge is temporary, the current trail is finished and
            added to the trail collection. The shortest path between the 
            start vertex <paramref name="s" /> and the target vertex of the
            temporary edge is then used to start the new trail. This shortest
            path is computed using the BreadthFirstSearchAlgorithm.
            </para>
      </remarks>
      <param name="s">start vertex</param>
      <returns>eulerian trail set, all starting at s</returns>
      <exception cref="T:System.ArgumentNullException">s is a null reference.</exception>
      <exception cref="T:System.Exception">Eulerian trail not computed yet.</exception>
      <requires>s != null</requires>
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.UndirectedVertexPredecessorRecorderObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.AlgorithmExtensions">
      <summary>
            Various extension methods to build algorithms
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.GetIndexer``2(System.Collections.Generic.Dictionary{``0,``1})">
      <summary>
            Returns the method that implement the access indexer.
            </summary>
      <typeparam name="TKey" />
      <typeparam name="TValue" />
      <param name="dictionary" />
      <returns />
      <requires>dictionary != null</requires>
      <ensures>Contract.Result&lt;Func&lt;TKey, TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.GetVertexIdentity``1(QuickGraph.IVertexSet{``0})">
      <summary>
            Gets the vertex identity.
            </summary>
      <remarks>
            Returns more efficient methods for primitive types,
            otherwise builds a dictionary
            </remarks>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <param name="graph">The graph.</param>
      <returns />
      <requires>graph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.GetEdgeIdentity``2(QuickGraph.IEdgeSet{``0,``1})">
      <summary>
            Gets the edge identity.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="graph">The graph.</param>
      <returns />
      <requires>graph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TreeDepthFirstSearch``2(QuickGraph.IVertexListGraph{``0,``1},``0)">
      <summary>
            Computes a depth first tree.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="visitedGraph">The visited graph.</param>
      <param name="root">The root.</param>
      <returns />
      <requires>visitedGraph != null</requires>
      <requires>root != null</requires>
      <requires>visitedGraph.ContainsVertex(root)</requires>
      <ensures>Contract.Result&lt;TryFunc&lt;TVertex, IEnumerable&lt;TEdge&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.RankedShortestPathHoffmanPavley``2(QuickGraph.IBidirectionalGraph{``0,``1},System.Func{``1,System.Double},``0,``0,System.Int32)">
      <summary>
            Computes the k-shortest path from <paramref name="source" /><paramref name="target" /> using Hoffman-Pavley algorithm.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <param name="edgeWeights" />
      <param name="source" />
      <param name="target" />
      <param name="pathCount" />
      <returns />
      <requires>visitedGraph != null</requires>
      <requires>edgeWeights != null</requires>
      <requires>source != null &amp;&amp; visitedGraph.ContainsVertex(source)</requires>
      <requires>target != null &amp;&amp; visitedGraph.ContainsVertex(target)</requires>
      <requires>pathCount &gt; 1</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.Sinks``2(QuickGraph.IVertexListGraph{``0,``1})">
      <summary>
            Gets the list of sink vertices
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <requires>visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.Roots``2(QuickGraph.IBidirectionalGraph{``0,``1})">
      <summary>
            Gets the list of root vertices
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <requires>visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.IsolatedVertices``2(QuickGraph.IBidirectionalGraph{``0,``1})">
      <summary>
            Gets the list of isolated vertices (no incoming or outcoming vertices)
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <requires>visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.Roots``2(QuickGraph.IVertexListGraph{``0,``1})">
      <summary>
            Gets the list of roots
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <requires>visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TopologicalSort``2(QuickGraph.IUndirectedGraph{``0,``1})">
      <summary>
            Creates a topological sort of a undirected
            acyclic graph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <exception cref="T:QuickGraph.NonAcyclicGraphException">the input graph
            has a cycle</exception>
      <requires>visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TopologicalSort``2(QuickGraph.IUndirectedGraph{``0,``1},System.Collections.Generic.IList{``0})">
      <summary>
            Creates a topological sort of a undirected
            acyclic graph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <param name="vertices" />
      <returns />
      <exception cref="T:QuickGraph.NonAcyclicGraphException">the input graph
            has a cycle</exception>
      <requires>visitedGraph != null</requires>
      <requires>vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TopologicalSort``2(QuickGraph.IVertexListGraph{``0,``1})">
      <summary>
            Creates a topological sort of a directed
            acyclic graph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <exception cref="T:QuickGraph.NonAcyclicGraphException">the input graph
            has a cycle</exception>
      <requires>visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TopologicalSort``2(QuickGraph.IVertexListGraph{``0,``1},System.Collections.Generic.IList{``0})">
      <summary>
            Creates a topological sort of a directed
            acyclic graph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <param name="vertices" />
      <returns />
      <exception cref="T:QuickGraph.NonAcyclicGraphException">the input graph
            has a cycle</exception>
      <requires>visitedGraph != null</requires>
      <requires>vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ConnectedComponents``2(QuickGraph.IUndirectedGraph{``0,``1},System.Collections.Generic.IDictionary{``0,System.Int32})">
      <summary>
            Computes the connected components of a graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="g" />
      <param name="components" />
      <returns>number of components</returns>
      <requires>g != null</requires>
      <requires>components != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.IncrementalConnectedComponents``2(QuickGraph.IMutableVertexAndEdgeSet{``0,``1})">
      <summary>
            Computes the incremental connected components for a growing graph (edge added only).
            Each call to the delegate re-computes the component dictionary. The returned dictionary
            is shared accross multiple calls of the method.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="g" />
      <returns />
      <requires>g != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.WeaklyConnectedComponents``2(QuickGraph.IVertexListGraph{``0,``1},System.Collections.Generic.IDictionary{``0,System.Int32})">
      <summary>
            Computes the weakly connected components of a graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="g" />
      <param name="components" />
      <returns>number of components</returns>
      <requires>g != null</requires>
      <requires>components != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.StronglyConnectedComponents``2(QuickGraph.IVertexListGraph{``0,``1},System.Collections.Generic.IDictionary{``0,System.Int32}@)">
      <summary>
            Computes the strongly connected components of a graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="g" />
      <param name="components" />
      <returns>number of components</returns>
      <requires>g != null</requires>
      <ensures>Contract.ValueAtReturn(out components) != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.Clone``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1},System.Func{``0,``0},System.Func{``1,``0,``0,``1},QuickGraph.IMutableVertexAndEdgeSet{``0,``1})">
      <summary>
            Clones a graph to another graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="g" />
      <param name="vertexCloner" />
      <param name="edgeCloner" />
      <param name="clone" />
      <requires>g != null</requires>
      <requires>vertexCloner != null</requires>
      <requires>edgeCloner != null</requires>
      <requires>clone != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.CondensateStronglyConnected``3(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <summary>
            Condensates the strongly connected components of a directed graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <typeparam name="TGraph" />
      <param name="g" />
      <returns />
      <requires>g != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.CondensateWeaklyConnected``3(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <summary>
            Condensates the weakly connected components of a graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <typeparam name="TGraph" />
      <param name="g" />
      <returns />
      <requires>g != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.OddVertices``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <summary>
            Create a collection of odd vertices
            </summary>
      <param name="g">graph to visit</param>
      <returns>colleciton of odd vertices</returns>
      <exception cref="T:System.ArgumentNullException">g is a null reference</exception>
      <requires>g != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.IsDirectedAcyclicGraph``2(QuickGraph.IVertexListGraph{``0,``1})">
      <summary>
            Gets a value indicating whether the graph is acyclic
            </summary>
      <remarks>
            Performs a depth first search to look for cycles.
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="g" />
      <returns />
      <requires>g != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ComputePredecessorCost``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``1,System.Double},``0)">
      <summary>
            Given a edge cost map, computes 
            the predecessor cost.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="predecessors" />
      <param name="edgeCosts" />
      <param name="target" />
      <returns />
      <requires>predecessors != null</requires>
      <requires>edgeCosts != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.MinimumSpanningTreePrim``2(QuickGraph.IUndirectedGraph{``0,``1},System.Func{``1,System.Double})">
      <summary>
            Computes the minimum spanning tree using Prim's algorithm.
            Prim's algorithm is simply implemented by calling Dijkstra shortest path.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <param name="weights" />
      <returns />
      <requires>visitedGraph != null</requires>
      <requires>weights != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.MinimumSpanningTreeKruskal``2(QuickGraph.IUndirectedGraph{``0,``1},System.Func{``1,System.Double})">
      <summary>
            Computes the minimum spanning tree using Kruskal's algorithm.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <param name="weights" />
      <returns />
      <requires>visitedGraph != null</requires>
      <requires>weights != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.OfflineLeastCommonAncestorTarjan``2(QuickGraph.IVertexListGraph{``0,``1},``0,System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{``0}})">
      <summary>
            Computes the offline least common ancestor between pairs of vertices in a rooted tree
            using Tarjan algorithm.
            </summary>
      <remarks>
            Reference:
            Gabow, H. N. and Tarjan, R. E. 1983. A linear-time algorithm for a special case of disjoint set union. In Proceedings of the Fifteenth Annual ACM Symposium on theory of Computing STOC '83. ACM, New York, NY, 246-251. DOI= http://doi.acm.org/10.1145/800061.808753 
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <param name="root" />
      <param name="pairs" />
      <returns />
      <requires>visitedGraph != null</requires>
      <requires>root != null</requires>
      <requires>pairs != null</requires>
      <requires>visitedGraph.ContainsVertex(root)</requires>
      <requires>Enumerable.All(pairs, p =&gt; visitedGraph.ContainsVertex(p.Source))</requires>
      <requires>Enumerable.All(pairs, p =&gt; visitedGraph.ContainsVertex(p.Target))</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.MaximumFlowEdmondsKarp``2(QuickGraph.IMutableVertexAndEdgeListGraph{``0,``1},System.Func{``1,System.Double},``0,``0,QuickGraph.TryFunc{``0,``1}@,QuickGraph.EdgeFactory{``0,``1})">
      <summary>
            Computes the Edmonds-Karp maximums flow 
            for a graph with positive capacities and
            flows.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="visitedGraph">The visited graph.</param>
      <param name="edgeCapacities">The edge capacities.</param>
      <param name="source">The source.</param>
      <param name="sink">The sink.</param>
      <param name="flowPredecessors">The flow predecessors.</param>
      <param name="edgeFactory">the edge factory</param>
      <returns />
      <requires>visitedGraph != null</requires>
      <requires>edgeCapacities != null</requires>
      <requires>source != null</requires>
      <requires>sink != null</requires>
      <requires>!source.Equals(sink)</requires>
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.VertexDistanceRecorderObserver`2">
      <summary>
            A distance recorder for directed tree builder algorithms
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
    </member>
    <member name="T:QuickGraph.EdgeEdgeAction`2">
      <summary>
            The handler for events involving two edges
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.IncrementalConnectedComponentsAlgorithm`2.GetComponents">
      <summary>
            Gets a copy of the connected components. Key is the number of components,
            Value contains the vertex -&gt; component index map.
            </summary>
      <returns />
      <ensures>
                Contract.Result&lt;KeyValuePair&lt;int, IDictionary&lt;TVertex, int&gt;&gt;&gt;().Key == this.ComponentCount</ensures>
      <ensures>
                Contract.Result&lt;KeyValuePair&lt;int, IDictionary&lt;TVertex, int&gt;&gt;&gt;().Value.Count == this.VisitedGraph.VertexCount</ensures>
    </member>
    <member name="T:QuickGraph.Algorithms.ComputationState">
      <summary>
            The computation state of a graph algorithm
            </summary>
    </member>
    <member name="F:QuickGraph.Algorithms.ComputationState.NotRunning">
      <summary>
            The algorithm is not running
            </summary>
    </member>
    <member name="F:QuickGraph.Algorithms.ComputationState.Running">
      <summary>
            The algorithm is running
            </summary>
    </member>
    <member name="F:QuickGraph.Algorithms.ComputationState.PendingAbortion">
      <summary>
            An abort has been requested. The algorithm is still running and will cancel as soon as it checks
            the cancelation state
            </summary>
    </member>
    <member name="F:QuickGraph.Algorithms.ComputationState.Finished">
      <summary>
            The computation is finished succesfully.
            </summary>
    </member>
    <member name="F:QuickGraph.Algorithms.ComputationState.Aborted">
      <summary>
            The computation was aborted
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.StronglyConnectedComponentsAlgorithm`2.FinishVertex(`0)">
      <summary>
            Used internally
            </summary>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.IsSelfEdge``2(``1)">
      <summary>
            Gets a value indicating if the edge is a self edge.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edge" />
      <returns />
      <pure />
      <requires>edge != null</requires>
      <ensures>Contract.Result&lt;bool&gt;() == (edge.Source.Equals(edge.Target))</ensures>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.GetOtherVertex``2(``1,``0)">
      <summary>
            Given a source vertex, returns the other vertex in the edge
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edge">must not be a self-edge</param>
      <param name="vertex" />
      <returns />
      <pure />
      <requires>edge != null</requires>
      <requires>vertex != null</requires>
      <requires>!edge.Source.Equals(edge.Target)</requires>
      <requires>edge.Source.Equals(vertex) || edge.Target.Equals(vertex)</requires>
      <ensures>Contract.Result&lt;TVertex&gt;() != null</ensures>
      <ensures>Contract.Result&lt;TVertex&gt;().Equals(edge.Source.Equals(vertex) ? edge.Target : edge.Source)</ensures>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.IsAdjacent``2(``1,``0)">
      <summary>
            Gets a value indicating if <paramref name="vertex" /> is adjacent to <paramref name="edge" />
            (is the source or target).
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edge" />
      <param name="vertex" />
      <returns />
      <pure />
      <requires>edge != null</requires>
      <requires>vertex != null</requires>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.ToVertexPair``2(``1)">
      <summary>
            Creates a vertex pair (source, target) from the edge
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edge" />
      <returns />
      <requires>edge != null</requires>
      <ensures>Contract.Result&lt;SEquatableEdge&lt;TVertex&gt;&gt;().Source.Equals(edge.Source)</ensures>
      <ensures>Contract.Result&lt;SEquatableEdge&lt;TVertex&gt;&gt;().Target.Equals(edge.Target)</ensures>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.IsPredecessor``2(System.Collections.Generic.IDictionary{``0,``1},``0,``0)">
      <summary>
            Checks that <paramref name="root" /> is a predecessor of <paramref name="vertex" /></summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="predecessors" />
      <param name="root" />
      <param name="vertex" />
      <returns />
      <requires>predecessors != null</requires>
      <requires>root != null</requires>
      <requires>vertex != null</requires>
      <requires>
                typeof(TEdge).IsValueType || 
                Enumerable.All(predecessors.Values, e =&gt; e != null)</requires>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.TryGetPath``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Collections.Generic.IEnumerable{``1}@)">
      <summary>
            Tries to get the predecessor path, if reachable.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="predecessors" />
      <param name="v" />
      <param name="result" />
      <returns />
      <requires>predecessors != null</requires>
      <requires>v != null</requires>
      <requires>
                typeof(TEdge).IsValueType ||
                Enumerable.All(predecessors.Values, e =&gt; e != null)</requires>
      <ensures>
                !Contract.Result&lt;bool&gt;() ||
                (Contract.ValueAtReturn&lt;IEnumerable&lt;TEdge&gt;&gt;(out result) != null &amp;&amp;
                 (typeof(TEdge).IsValueType ||
                 Enumerable.All(
                    Contract.ValueAtReturn&lt;IEnumerable&lt;TEdge&gt;&gt;(out result),
                    e =&gt; e != null))
                )</ensures>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.GetUndirectedVertexEquality``2">
      <summary>
            Returns the most efficient comporer for the particular type of TEdge.
            If TEdge implements IUndirectedEdge, then only the (source,target) pair
            has to be compared; if not, (source, target) and (target, source) have to be compared.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <returns />
    </member>
    <member name="M:QuickGraph.EdgeExtensions.UndirectedVertexEquality``2(``1,``0,``0)">
      <summary>
            Gets a value indicating if the vertices of edge match (source, target) or
            (target, source)
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edge" />
      <param name="source" />
      <param name="target" />
      <returns />
      <requires>edge != null</requires>
      <requires>source != null</requires>
      <requires>target != null</requires>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.SortedVertexEquality``2(``1,``0,``0)">
      <summary>
            Gets a value indicating if the vertices of edge match (source, target)
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edge" />
      <param name="source" />
      <param name="target" />
      <returns />
      <requires>edge != null</requires>
      <requires>source != null</requires>
      <requires>target != null</requires>
      <requires>Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0</requires>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.ReverseEdges``2(System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Returns a reversed edge enumeration
            </summary>
      <param name="edges" />
      <returns />
    </member>
    <member name="T:QuickGraph.BidirectionAdapterGraph`2">
      <summary>
            Wraps a vertex list graph (out-edges only) and caches the in-edge dictionary.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2">
      <summary>
            Hoffman and Pavley K-shortest path algorithm.
            </summary>
      <remarks>
            Reference:
            Hoffman, W. and Pavley, R. 1959. A Method for the Solution of the Nth Best Path Problem. 
            J. ACM 6, 4 (Oct. 1959), 506-514. DOI= http://doi.acm.org/10.1145/320998.321004
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.DelegateVertexAndEdgeListGraph`2">
      <summary>
            A delegate-based incidence graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Predicates.IsolatedVertexPredicate`2">
      <summary>
            A vertex predicate that detects vertex with no in or out edges.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.SUndirectedEdge`1">
      <summary>
            An struct based <see cref="T:QuickGraph.IUndirectedEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
    </member>
    <member name="M:QuickGraph.SUndirectedEdge`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.SUndirectedEdge`1" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <requires>source != null</requires>
      <requires>target != null</requires>
      <requires>Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0</requires>
      <ensures>Contract.ValueAtReturn(out this).Source.Equals(source)</ensures>
      <ensures>Contract.ValueAtReturn(out this).Target.Equals(target)</ensures>
    </member>
    <member name="M:QuickGraph.SUndirectedEdge`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:QuickGraph.SUndirectedEdge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.SUndirectedEdge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.BreadthFirstSearchAlgorithm`2">
      <summary>
            A breath first search algorithm for directed graphs
            </summary>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.VertexPredecessorPathRecorderObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.UndirectedVertexDistanceRecorderObserver`2">
      <summary>
            A distance recorder for undirected tree builder algorithms
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
    </member>
    <member name="T:QuickGraph.NonStronglyConnectedGraphException">
      <summary>
            Exception raised when an algorithm detects a non-strongly connected graph.
            </summary>
    </member>
    <member name="T:QuickGraph.IdentifiableVertexFactory`1">
      <summary>
            A factory of identifiable vertices.
            </summary>
    </member>
    <member name="T:QuickGraph.CreateVertexDelegate`2">
      <summary>
            A vertex factory delegate.
            </summary>
    </member>
    <member name="M:QuickGraph.HashCodeHelper.Combine(System.Int32,System.Int32)">
      <summary>
            Combines two hashcodes in a strong way.
            </summary>
      <param name="x" />
      <param name="y" />
      <returns />
    </member>
    <member name="M:QuickGraph.HashCodeHelper.Combine(System.Int32,System.Int32,System.Int32)">
      <summary>
            Combines three hashcodes in a strong way.
            </summary>
      <param name="x" />
      <param name="y" />
      <param name="z" />
      <returns />
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.VertexRecorderObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.TryGetEdge(`0,`0,`1@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="P:QuickGraph.BidirectionAdapterGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.IsOutEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;bool&gt;() == (ithis.OutDegree(v) == 0)</ensures>
    </member>
    <member name="P:QuickGraph.BidirectionAdapterGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionAdapterGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.ContainsEdge(`0,`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.OutEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Enumerable.All(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e.Source.Equals(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || Contract.ValueAtReturn(out edges) != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || 
                Enumerable.All(
                Contract.ValueAtReturn&lt;IEnumerable&lt;TEdge&gt;&gt;(out edges),
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.OutDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;int&gt;() == Enumerable.Count&lt;TEdge&gt;(ithis.OutEdges(v))</ensures>
    </member>
    <member name="P:QuickGraph.BidirectionAdapterGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.IsInEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == (ithis.InDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.#ctor(QuickGraph.IVertexAndEdgeListGraph{`0,`1})">
      <requires>baseGraph != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.InEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;TEdge&gt;().Equals(Enumerable.ElementAt(ithis.InEdges(v), index))</ensures>
    </member>
    <member name="P:QuickGraph.BidirectionAdapterGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionAdapterGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.InEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Enumerable.All(
                Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), 
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">!Contract.Result&lt;bool&gt;() || 
                (Contract.ValueAtReturn(out edges) != null &amp;&amp; 
                 Enumerable.All(Contract.ValueAtReturn(out edges), e =&gt; e.Source.Equals(v)))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.InDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.Degree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == ithis.InDegree(v) + ithis.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.OutEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">
                Enumerable.ElementAt(ithis.OutEdges(v), index).Equals(Contract.Result&lt;TEdge&gt;())</ensures>
    </member>
    <member name="P:QuickGraph.STaggedEdge`2.Source">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.STaggedEdge`2.Target">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.STaggedEdge`2.#ctor(`0,`0,`1)">
      <requires>source != null</requires>
      <requires>target != null</requires>
    </member>
    <member name="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires>source != null</requires>
      <requires>target != null</requires>
      <requires>ithis.ContainsVertex(source)</requires>
      <requires>ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)">
      <requires>source != null</requires>
      <requires>target != null</requires>
      <requires>ithis.ContainsVertex(source)</requires>
      <requires>ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires>source != null</requires>
      <requires>target != null</requires>
      <requires>ithis.ContainsVertex(source)</requires>
      <requires>ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == (ithis.InDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.#ctor(QuickGraph.TryFunc{`0,System.Collections.Generic.IEnumerable{`1}},QuickGraph.TryFunc{`0,System.Collections.Generic.IEnumerable{`1}})">
      <requires>tryGetInEdges != null</requires>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;TEdge&gt;().Equals(Enumerable.ElementAt(ithis.InEdges(v), index))</ensures>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.InEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Enumerable.All(
                Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), 
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.InDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.Degree(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == ithis.InDegree(v) + ithis.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || Contract.ValueAtReturn(out edges) != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || 
                Enumerable.All(
                Contract.ValueAtReturn&lt;IEnumerable&lt;TEdge&gt;&gt;(out edges),
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.RemoveVertexIf(QuickGraph.VertexPredicate{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet">pred != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet">Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.Vertices, v =&gt; pred(v)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet">Enumerable.All(ithis.Vertices, v =&gt; !pred(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet">ithis.VertexCount == Contract.OldValue(ithis.VertexCount) - Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">predicate != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.Edges, e =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(ithis.Edges, e =&gt; !predicate(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.RemoveVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet">Contract.Result&lt;bool&gt;() == Contract.OldValue(ithis.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet">!ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet">ithis.VertexCount == Contract.OldValue(ithis.VertexCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.IsDirected">
      <getter>
        <pure />
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.Vertices">
      <getter>
        <pure />
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.Degree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == ithis.InDegree(v) + ithis.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.ClearEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph">!ithis.ContainsVertex(v)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.#ctor(QuickGraph.Collections.IVertexEdgeDictionary{`0,`1},QuickGraph.Collections.IVertexEdgeDictionary{`0,`1},System.Int32,System.Int32,System.Boolean)">
      <requires>vertexInEdges != null</requires>
      <requires>vertexOutEdges != null</requires>
      <requires>edgeCount &gt;= 0</requires>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.EdgeType">
      <getter>
        <pure />
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.AddVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet">Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet">ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet">ithis.VertexCount == Contract.OldValue(ithis.VertexCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet">typeof(TEdge).IsValueType || Enumerable.All(edges, edge =&gt; edge != null)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">typeof(TEdge).IsValueType || Enumerable.All(edges, edge =&gt; edge != null)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(edges, edge =&gt;
                ithis.ContainsVertex(edge.Source) &amp;&amp;
                ithis.ContainsVertex(edge.Target)
                )</requires>
      <ensures description="all edge from edges belong to the graph" inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(edges, edge =&gt; ithis.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">
                Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(edges, edge =&gt; !ithis.ContainsEdge(edge)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">!Contract.Result&lt;bool&gt;() || 
                (Contract.ValueAtReturn(out edges) != null &amp;&amp; 
                 Enumerable.All(Contract.ValueAtReturn(out edges), e =&gt; e.Source.Equals(v)))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.RemoveEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">e != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">Contract.Result&lt;bool&gt;() == Contract.OldValue(ithis.ContainsEdge(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">!ithis.ContainsEdge(e)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.OutEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Enumerable.All(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e.Source.Equals(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.InDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || Contract.ValueAtReturn(out edges) != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || 
                Enumerable.All(
                Contract.ValueAtReturn&lt;IEnumerable&lt;TEdge&gt;&gt;(out edges),
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.AddEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">e != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsVertex(e.Source)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsVertex(e.Target)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsEdge(e)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsEdge(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.IsInEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == (ithis.InDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.ClearInEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearInEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearInEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearInEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - Contract.OldValue(ithis.InDegree(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearInEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph">ithis.InDegree(v) == 0</ensures>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.IsVerticesEmpty">
      <getter>
        <pure />
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.IsOutEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;bool&gt;() == (ithis.OutDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.OutEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">
                Enumerable.ElementAt(ithis.OutEdges(v), index).Equals(Contract.Result&lt;TEdge&gt;())</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.TryGetEdge(`0,`0,`1@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.AllowParallelEdges">
      <getter>
        <pure />
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.#ctor(System.Boolean,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <requires>vertexComparer != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.AddVerticesAndEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet">ithis.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet">ithis.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.OutDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;int&gt;() == Enumerable.Count&lt;TEdge&gt;(ithis.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph">predicate != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph">ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph">Enumerable.All(ithis.InEdges(v), e =&gt; predicate(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph">Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.InEdges(v), e =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph">ithis.InDegree(v) == Contract.OldValue(ithis.InDegree(v)) - Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.EdgeCapacity">
      <getter>
        <pure />
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph">predicate != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph">Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.OutEdges(v), ve =&gt; predicate(ve)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph">Enumerable.All(ithis.OutEdges(v), ve =&gt; !predicate(ve))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.#ctor(System.Boolean,System.Int32,System.Func{System.Int32,QuickGraph.Collections.IVertexEdgeDictionary{`0,`1}})">
      <requires>vertexEdgesDictionaryFactory != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.AddVertexRange(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet">vertices != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet">Enumerable.All(vertices, v =&gt; v != null)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet">Enumerable.All(vertices, v =&gt; ithis.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet">ithis.VertexCount == Contract.OldValue(ithis.VertexCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.MergeVertexIf(QuickGraph.VertexPredicate{`0},QuickGraph.EdgeFactory{`0,`1})">
      <requires>vertexPredicate != null</requires>
      <requires>edgeFactory != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.ContainsEdge(`0,`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.InEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;TEdge&gt;().Equals(Enumerable.ElementAt(ithis.InEdges(v), index))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.InEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Enumerable.All(
                Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), 
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.VertexCount">
      <getter>
        <pure />
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.MergeVertex(`0,QuickGraph.EdgeFactory{`0,`1})">
      <requires>GraphContract.InVertexSet(this, v)</requires>
      <requires>edgeFactory != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.ClearOutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)" inheritedFromTypeName="IMutableIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)" inheritedFromTypeName="IMutableIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)" inheritedFromTypeName="IMutableIncidenceGraph">ithis.OutDegree(v) == 0</ensures>
    </member>
    <member name="P:QuickGraph.ReversedBidirectionalGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.TryGetEdge(`0,`0,QuickGraph.SReversedEdge{`0,`1}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="P:QuickGraph.ReversedBidirectionalGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ReversedBidirectionalGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ReversedBidirectionalGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{QuickGraph.SReversedEdge{`0,`1}}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">!Contract.Result&lt;bool&gt;() || 
                (Contract.ValueAtReturn(out edges) != null &amp;&amp; 
                 Enumerable.All(Contract.ValueAtReturn(out edges), e =&gt; e.Source.Equals(v)))</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.OutEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Enumerable.All(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e.Source.Equals(v))</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{QuickGraph.SReversedEdge{`0,`1}}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || Contract.ValueAtReturn(out edges) != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || 
                Enumerable.All(
                Contract.ValueAtReturn&lt;IEnumerable&lt;TEdge&gt;&gt;(out edges),
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.OutDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;int&gt;() == Enumerable.Count&lt;TEdge&gt;(ithis.OutEdges(v))</ensures>
    </member>
    <member name="P:QuickGraph.ReversedBidirectionalGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.ContainsEdge(QuickGraph.SReversedEdge{`0,`1})">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.IsInEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == (ithis.InDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.#ctor(QuickGraph.IBidirectionalGraph{`0,`1})">
      <requires>originalGraph != null</requires>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.InEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;TEdge&gt;().Equals(Enumerable.ElementAt(ithis.InEdges(v), index))</ensures>
    </member>
    <member name="P:QuickGraph.ReversedBidirectionalGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.InEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Enumerable.All(
                Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), 
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.IsOutEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;bool&gt;() == (ithis.OutDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.OutEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">
                Enumerable.ElementAt(ithis.OutEdges(v), index).Equals(Contract.Result&lt;TEdge&gt;())</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.InDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.Degree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == ithis.InDegree(v) + ithis.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{QuickGraph.SReversedEdge{`0,`1}}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.DelegateIncidenceGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.DelegateIncidenceGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.DelegateIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.Range.#ctor(System.Int32,System.Int32)">
      <requires>start &gt;= 0</requires>
      <requires>start &lt;= end</requires>
      <ensures>Contract.ValueAtReturn(out this).Start == start</ensures>
      <ensures>Contract.ValueAtReturn(out this).End == end</ensures>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.Range.Length">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.TryGetEdge(`0,`0,QuickGraph.SEquatableEdge{`0}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.OutDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;int&gt;() == Enumerable.Count&lt;TEdge&gt;(ithis.OutEdges(v))</ensures>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{`0}}@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">!Contract.Result&lt;bool&gt;() || 
                (Contract.ValueAtReturn(out edges) != null &amp;&amp; 
                 Enumerable.All(Contract.ValueAtReturn(out edges), e =&gt; e.Source.Equals(v)))</ensures>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.OutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Enumerable.All(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e.Source.Equals(v))</ensures>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.ContainsVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.FromGraph``1(QuickGraph.IVertexAndEdgeListGraph{`0,``0})">
      <requires>visitedGraph != null</requires>
      <ensures>Contract.Result&lt;CompressedSparseRowGraph&lt;TVertex&gt;&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.ContainsEdge(QuickGraph.SEquatableEdge{`0})">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.#ctor(System.Collections.Generic.Dictionary{`0,QuickGraph.CompressedSparseRowGraph{`0}.Range},`0[])">
      <requires>outEdgeStartRanges != null</requires>
      <requires>outEdges != null</requires>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.IsOutEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;bool&gt;() == (ithis.OutDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{`0}}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.OutEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">
                Enumerable.ElementAt(ithis.OutEdges(v), index).Equals(Contract.Result&lt;TEdge&gt;())</ensures>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.HasCycles``2(System.Collections.Generic.IEnumerable{``1})">
      <pure />
      <requires>path != null</requires>
      <requires>typeof(TEdge).IsValueType || Enumerable.All(path, e =&gt; e != null)</requires>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.IsPathWithoutCycles``2(System.Collections.Generic.IEnumerable{``1})">
      <pure />
      <requires>path != null</requires>
      <requires>typeof(TEdge).IsValueType || Enumerable.All(path, e =&gt; e != null)</requires>
      <requires>IsPath&lt;TVertex, TEdge&gt;(path)</requires>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.IsPath``2(System.Collections.Generic.IEnumerable{``1})">
      <pure />
      <requires>path != null</requires>
      <requires>typeof(TEdge).IsValueType || Enumerable.All(path, e =&gt; e != null)</requires>
    </member>
    <member name="M:QuickGraph.TaggedEquatableEdge`2.#ctor(`0,`0,`1)">
      <ensures>Object.Equals(this.Tag, tag)</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Services.AlgorithmServices.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent)">
      <requires>host != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ShortestPathsDijkstra``2(QuickGraph.IUndirectedGraph{``0,``1},System.Func{``1,System.Double},``0)">
      <requires>visitedGraph != null</requires>
      <requires>edgeWeights != null</requires>
      <requires>source != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ShortestPathsAStar``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1},System.Func{``1,System.Double},System.Func{``0,System.Double},``0)">
      <requires>visitedGraph != null</requires>
      <requires>edgeWeights != null</requires>
      <requires>costHeuristic != null</requires>
      <requires>source != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.CondensateEdges``2(QuickGraph.IBidirectionalGraph{``0,``1},QuickGraph.VertexPredicate{``0})">
      <requires>visitedGraph != null</requires>
      <requires>vertexPredicate != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TreeBreadthFirstSearch``2(QuickGraph.IVertexListGraph{``0,``1},``0)">
      <requires>visitedGraph != null</requires>
      <requires>root != null</requires>
      <requires>visitedGraph.ContainsVertex(root)</requires>
      <ensures>Contract.Result&lt;TryFunc&lt;TVertex, IEnumerable&lt;TEdge&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ComputeDisjointSet``2(QuickGraph.IUndirectedGraph{``0,``1})">
      <requires>visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.SourceFirstTopologicalSort``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <requires>visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ShortestPathsDag``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1},System.Func{``1,System.Double},``0)">
      <requires>visitedGraph != null</requires>
      <requires>edgeWeights != null</requires>
      <requires>source != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TreeCyclePoppingRandom``2(QuickGraph.IVertexListGraph{``0,``1},``0)">
      <requires>visitedGraph != null</requires>
      <requires>root != null</requires>
      <requires>visitedGraph.ContainsVertex(root)</requires>
      <ensures>Contract.Result&lt;TryFunc&lt;TVertex, IEnumerable&lt;TEdge&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ShortestPathsBellmanFord``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1},System.Func{``1,System.Double},``0)">
      <requires>visitedGraph != null</requires>
      <requires>edgeWeights != null</requires>
      <requires>source != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.SourceFirstTopologicalSort``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1},System.Collections.Generic.IList{``0})">
      <requires>visitedGraph != null</requires>
      <requires>vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TreeCyclePoppingRandom``2(QuickGraph.IVertexListGraph{``0,``1},``0,QuickGraph.Algorithms.RandomWalks.IMarkovEdgeChain{``0,``1})">
      <requires>visitedGraph != null</requires>
      <requires>root != null</requires>
      <requires>visitedGraph.ContainsVertex(root)</requires>
      <ensures>Contract.Result&lt;TryFunc&lt;TVertex, IEnumerable&lt;TEdge&gt;&gt;&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ShortestPathsDijkstra``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1},System.Func{``1,System.Double},``0)">
      <requires>visitedGraph != null</requires>
      <requires>edgeWeights != null</requires>
      <requires>source != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.EnqueueDeviationPaths(QuickGraph.Collections.IQueue{QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm{`0,`1}.DeviationPath},System.Collections.Generic.IDictionary{`0,System.Double},`1[],System.Int32,`0,System.Double,System.Collections.Generic.Dictionary{`0,System.Int32})">
      <requires>queue != null</requires>
      <requires>distances != null</requires>
      <requires>path != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.SetGoalVertex(`0)">
      <requires>goalVertex != null</requires>
      <requires>this.VisitedGraph.ContainsVertex(goalVertex)</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.Compute(`0,`0)">
      <requires>rootVertex != null</requires>
      <requires>goalVertex != null</requires>
      <requires>this.VisitedGraph.ContainsVertex(rootVertex)</requires>
      <requires>this.VisitedGraph.ContainsVertex(goalVertex)</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.EnqueueDeviationPaths(QuickGraph.Collections.IQueue{QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm{`0,`1}.DeviationPath},`0,System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`0,System.Double},`1[],System.Int32)">
      <requires>queue != null</requires>
      <requires>root != null</requires>
      <requires>successors != null</requires>
      <requires>distances != null</requires>
      <requires>path != null</requires>
      <requires>EdgeExtensions.IsAdjacent&lt;TVertex, TEdge&gt;(path[0], root)</requires>
      <requires>0 &lt;= startEdge &amp;&amp; startEdge &lt; path.Length</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.DeviationPath.#ctor(`1[],System.Int32,`1,System.Double)">
      <requires>parentPath != null</requires>
      <requires>0 &lt;= deviationIndex &amp;&amp; deviationIndex &lt; parentPath.Length</requires>
      <requires>deviationEdge != null</requires>
      <requires>weight &gt;= 0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.DeviationPath.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IBidirectionalGraph{`0,`1},System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires>edgeWeights != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.EnqueueFirstShortestPath(QuickGraph.Collections.IQueue{QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm{`0,`1}.DeviationPath},System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`0,System.Double},`0)">
      <requires>queue != null</requires>
      <requires>queue.Count == 0</requires>
      <requires>successors != null</requires>
      <requires>distances != null</requires>
      <requires>root != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.AppendShortestPath(System.Collections.Generic.List{`1},System.Collections.Generic.IDictionary{`0,`1},`0)">
      <requires>path != null</requires>
      <requires>successors != null</requires>
      <requires>startVertex != null</requires>
      <ensures>path[path.Count - 1].Target.Equals(this.goalVertex)</ensures>
    </member>
    <member name="P:QuickGraph.Algorithms.RankedShortestPath.RankedShortestPathAlgorithmBase`3.ComputedShortestPathCount">
      <getter>
        <ensures>Contract.Result&lt;int&gt;() == Enumerable.Count(this.ComputedShortestPaths)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.RankedShortestPathAlgorithmBase`3.AddComputedShortestPath(System.Collections.Generic.List{`1})">
      <requires>path != null</requires>
      <requires>Enumerable.All(path, e =&gt; e != null)</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.RankedShortestPathAlgorithmBase`3.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,`2,QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires>distanceRelaxer != null</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.RankedShortestPath.RankedShortestPathAlgorithmBase`3.ShortestPathCount">
      <setter>
        <requires>value &gt; 1</requires>
        <ensures>this.ShortestPathCount == value</ensures>
      </setter>
    </member>
    <member name="M:QuickGraph.Algorithms.Condensation.EdgeMergeCondensationGraphAlgorithm`2.#ctor(QuickGraph.IBidirectionalGraph{`0,`1},QuickGraph.IMutableBidirectionalGraph{`0,QuickGraph.Algorithms.Condensation.MergedEdge{`0,`1}},QuickGraph.VertexPredicate{`0})">
      <requires>condensatedGraph != null</requires>
      <requires>vertexPredicate != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumBipartiteMatchingAlgorithm`2.#ctor(QuickGraph.IMutableVertexAndEdgeListGraph{`0,`1},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},QuickGraph.VertexFactory{`0},QuickGraph.EdgeFactory{`0,`1})">
      <requires>vertexFactory != null</requires>
      <requires>edgeFactory != null</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.AlgorithmBase`1.SyncRoot">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.Algorithms.IComputation.get_SyncRoot" inheritedFromTypeName="IComputation">Contract.Result&lt;object&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Algorithms.AlgorithmBase`1.VisitedGraph">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.Algorithms.IAlgorithm`1.get_VisitedGraph" inheritedFromTypeName="IAlgorithm">Contract.Result&lt;TGraph&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmBase`1.BeginComputation">
      <requires>this.State == ComputationState.NotRunning</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.AlgorithmBase`1.State">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.Algorithms.IComputation.get_State" inheritedFromTypeName="IComputation">Enum.IsDefined(typeof(ComputationState), Contract.Result&lt;ComputationState&gt;())</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmBase`1.#ctor(`0)">
      <requires>visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmBase`1.TryGetService(System.Type,System.Object@)">
      <requires>serviceType != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmBase`1.EndComputation">
      <requires>
                this.State == ComputationState.Running || 
                this.State == ComputationState.Aborted</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.EdmondsKarpMaximumFlowAlgorithm`2.Augment(`0,`0)">
      <requires>source != null</requires>
      <requires>sink != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphBalancerAlgorithm`2.#ctor(QuickGraph.IMutableBidirectionalGraph{`0,`1},`0,`0,QuickGraph.VertexFactory{`0},QuickGraph.EdgeFactory{`0,`1})">
      <requires>visitedGraph != null</requires>
      <requires>vertexFactory != null</requires>
      <requires>edgeFactory != null</requires>
      <requires>source != null</requires>
      <requires>visitedGraph.ContainsVertex(source)</requires>
      <requires>sink != null</requires>
      <requires>visitedGraph.ContainsVertex(sink)</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphBalancerAlgorithm`2.GetBalancingIndex(`0)">
      <requires>v != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphBalancerAlgorithm`2.OnDeficientVertexAdded(`0)">
      <requires>vertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphBalancerAlgorithm`2.OnSurplusVertexAdded(`0)">
      <requires>vertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphBalancerAlgorithm`2.#ctor(QuickGraph.IMutableBidirectionalGraph{`0,`1},QuickGraph.VertexFactory{`0},QuickGraph.EdgeFactory{`0,`1},`0,`0,System.Collections.Generic.IDictionary{`1,System.Double})">
      <requires>visitedGraph != null</requires>
      <requires>vertexFactory != null</requires>
      <requires>edgeFactory != null</requires>
      <requires>source != null</requires>
      <requires>visitedGraph.ContainsVertex(source)</requires>
      <requires>sink != null</requires>
      <requires>visitedGraph.ContainsVertex(sink)</requires>
      <requires>capacities != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphBalancerAlgorithm`2.OnEdgeAdded(`1)">
      <requires>edge != null</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.MaximumFlow.MaximumFlowAlgorithm`2.Sink">
      <setter>
        <requires>value != null</requires>
      </setter>
    </member>
    <member name="P:QuickGraph.Algorithms.MaximumFlow.MaximumFlowAlgorithm`2.Source">
      <setter>
        <requires>value != null</requires>
      </setter>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.MaximumFlowAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IMutableVertexAndEdgeListGraph{`0,`1},System.Func{`1,System.Double},QuickGraph.EdgeFactory{`0,`1})">
      <requires>capacities != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphAugmentorAlgorithmBase`3.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,`2,QuickGraph.VertexFactory{`0},QuickGraph.EdgeFactory{`0,`1})">
      <requires>vertexFactory != null</requires>
      <requires>edgeFactory != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphAugmentorAlgorithmBase`3.OnSuperSourceAdded(`0)">
      <requires>v != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphAugmentorAlgorithmBase`3.OnEdgeAdded(`1)">
      <requires>e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphAugmentorAlgorithmBase`3.OnSuperSinkAdded(`0)">
      <requires>v != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.ReversedEdgeAugmentorAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IMutableVertexAndEdgeListGraph{`0,`1},QuickGraph.EdgeFactory{`0,`1})">
      <requires>visitedGraph != null</requires>
      <requires>edgeFactory != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.WeightedMarkovEdgeChainBase`2.#ctor(System.Collections.Generic.IDictionary{`1,System.Double})">
      <requires>weights != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.WeightedMarkovEdgeChainBase`2.TryGetSuccessor(System.Collections.Generic.IEnumerable{`1},System.Double,`1@)">
      <requires>edges != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.WeightedMarkovEdgeChainBase`2.TryGetSuccessor(QuickGraph.IImplicitGraph{`0,`1},`0,System.Double,`1@)">
      <requires>g != null</requires>
      <requires>u != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.CyclePoppingRandomTreeAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},QuickGraph.Algorithms.RandomWalks.IMarkovEdgeChain{`0,`1})">
      <requires>edgeChain != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.CyclePoppingRandomTreeAlgorithm`2.RandomTreeWithRoot(`0)">
      <requires>root != null</requires>
      <requires>this.VisitedGraph.ContainsVertex(root)</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.CyclePoppingRandomTreeAlgorithm`2.Tree(`0,`1)">
      <requires>next != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.RandomWalkAlgorithm`2.#ctor(QuickGraph.IImplicitGraph{`0,`1},QuickGraph.Algorithms.RandomWalks.IEdgeChain{`0,`1})">
      <requires>visitedGraph != null</requires>
      <requires>edgeChain != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.RandomWalkAlgorithm`2.Generate(`0)">
      <requires>root != null</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.RandomWalks.RandomWalkAlgorithm`2.EdgeChain">
      <setter>
        <requires>value != null</requires>
      </setter>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.RandomWalkAlgorithm`2.Generate(`0,System.Int32)">
      <requires>root != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.CentralityApproximationAlgorithm`2.#ctor(QuickGraph.IVertexListGraph{`0,`1},System.Func{`1,System.Double})">
      <requires>distances != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.LengauerTarjanDominatorAlgorithm`2.TimeStampObserver.#ctor(System.Collections.Generic.List{`0})">
      <requires>vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.LengauerTarjanDominatorAlgorithm`2.TimeStampObserver.Attach(QuickGraph.Algorithms.IVertexTimeStamperAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.RootedAlgorithmBase`2.OnRootVertexChanged(System.EventArgs)">
      <requires>e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RootedAlgorithmBase`2.Compute(`0)">
      <requires>rootVertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RootedAlgorithmBase`2.SetRootVertex(`0)">
      <requires>rootVertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.TopologicalSort.TopologicalSortAlgorithm`2.#ctor(QuickGraph.IVertexListGraph{`0,`1},System.Collections.Generic.IList{`0})">
      <requires>vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.TopologicalSort.UndirectedFirstTopologicalSortAlgorithm`2.Compute(System.Collections.Generic.IList{`0})">
      <requires>vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.TopologicalSort.SourceFirstTopologicalSortAlgorithm`2.Compute(System.Collections.Generic.IList{`0})">
      <requires>vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.TopologicalSort.UndirectedTopologicalSortAlgorithm`2.#ctor(QuickGraph.IUndirectedGraph{`0,`1},System.Collections.Generic.IList{`0})">
      <requires>vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RootedSearchAlgorithmBase`2.Compute(`0,`0)">
      <requires>root != null</requires>
      <requires>goal != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RootedSearchAlgorithmBase`2.SetGoalVertex(`0)">
      <requires>goalVertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RootedSearchAlgorithmBase`2.OnGoalVertexChanged(System.EventArgs)">
      <requires>e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.SearchFrame.#ctor(`0,System.Collections.Generic.IEnumerator{`1},System.Int32)">
      <requires>vertex != null</requires>
      <requires>edges != null</requires>
      <requires>depth &gt;= 0</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.MaxDepth">
      <setter>
        <requires>value &gt; 0</requires>
      </setter>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.Visit(`0)">
      <requires>root != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.EdgeDepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IEdgeListAndIncidenceGraph{`0,`1},System.Collections.Generic.IDictionary{`1,QuickGraph.GraphColor})">
      <requires>colors != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.BestFirstFrontierSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IBidirectionalIncidenceGraph{`0,`1},System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires>edgeWeights != null</requires>
      <requires>distanceRelaxer != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.BidirectionalDepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IBidirectionalGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor})">
      <requires>colors != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.BidirectionalDepthFirstSearchAlgorithm`2.Visit(`0,System.Int32)">
      <requires>u != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.BreadthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},QuickGraph.Collections.IQueue{`0},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor},System.Func{System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`1}})">
      <requires>vertexQueue != null</requires>
      <requires>vertexColors != null</requires>
      <requires>outEdgeEnumerator != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.SearchFrame.#ctor(`0,System.Collections.Generic.IEnumerator{`1},System.Int32)">
      <requires>vertex != null</requires>
      <requires>edges != null</requires>
      <requires>depth &gt;= 0</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.MaxDepth">
      <setter>
        <requires>value &gt; 0</requires>
      </setter>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.Visit(`0)">
      <requires>root != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.OnStartVertex(`0)">
      <requires>v != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.OnVertexMaxDepthReached(`0)">
      <requires>v != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.OnInitializeVertex(`0)">
      <requires>v != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedBreadthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IUndirectedGraph{`0,`1},QuickGraph.Collections.IQueue{`0},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor})">
      <requires>vertexQueue != null</requires>
      <requires>vertexColors != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.OnVisitEdge(`1)">
      <requires>e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.Search(`0)">
      <requires>u != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.OnCircuitEdge(`1)">
      <requires>e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.OnTreeEdge(`1)">
      <requires>e != null</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.IComputation.SyncRoot">
      <getter>
        <ensures>Contract.Result&lt;object&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Algorithms.IComputation.State">
      <getter>
        <ensures>Enum.IsDefined(typeof(ComputationState), Contract.Result&lt;ComputationState&gt;())</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexPredecessorPathRecorderObserver`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <requires>vertexPredecessors != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexPredecessorPathRecorderObserver`2.Attach(QuickGraph.Algorithms.IVertexPredecessorRecorderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexRecorderObserver`2.#ctor(System.Collections.Generic.IList{`0})">
      <requires>vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexRecorderObserver`2.Attach(QuickGraph.Algorithms.IVertexTimeStamperAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexPredecessorRecorderObserver`2.#ctor(System.Collections.Generic.Dictionary{`0,`1})">
      <requires>vertexPredecessors != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexPredecessorRecorderObserver`2.Attach(QuickGraph.Algorithms.ITreeBuilderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.UndirectedVertexPredecessorRecorderObserver`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <requires>vertexPredecessors != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.UndirectedVertexPredecessorRecorderObserver`2.Attach(QuickGraph.Algorithms.IUndirectedTreeBuilderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.EdgePredecessorRecorderObserver`2.#ctor(System.Collections.Generic.IDictionary{`1,`1},System.Collections.Generic.IList{`1})">
      <requires>edgePredecessors != null</requires>
      <requires>endPathEdges != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.EdgePredecessorRecorderObserver`2.Attach(QuickGraph.Algorithms.IEdgePredecessorRecorderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexDistanceRecorderObserver`2.#ctor(System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer,System.Collections.Generic.IDictionary{`0,System.Double})">
      <requires>edgeWeights != null</requires>
      <requires>distanceRelaxer != null</requires>
      <requires>distances != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexDistanceRecorderObserver`2.Attach(QuickGraph.Algorithms.ITreeBuilderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexTimeStamperObserver`2.#ctor(System.Collections.Generic.Dictionary{`0,System.Int32})">
      <requires>discoverTimes != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexTimeStamperObserver`2.#ctor(System.Collections.Generic.Dictionary{`0,System.Int32},System.Collections.Generic.Dictionary{`0,System.Int32})">
      <requires>discoverTimes != null</requires>
      <requires>finishTimes != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexTimeStamperObserver`2.Attach(QuickGraph.Algorithms.IVertexTimeStamperAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.UndirectedVertexDistanceRecorderObserver`2.#ctor(System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer,System.Collections.Generic.IDictionary{`0,System.Double})">
      <requires>edgeWeights != null</requires>
      <requires>distanceRelaxer != null</requires>
      <requires>distances != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.UndirectedVertexDistanceRecorderObserver`2.Attach(QuickGraph.Algorithms.IUndirectedTreeBuilderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.DisposableAction.#ctor(QuickGraph.Algorithms.Observers.DisposableAction.Action)">
      <requires>action != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.EdgeRecorderObserver`2.#ctor(System.Collections.Generic.IList{`1})">
      <requires>edges != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.EdgeRecorderObserver`2.Attach(QuickGraph.Algorithms.ITreeBuilderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver">Contract.Result&lt;IDisposable&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.EdgeRecorderObserver`2.RecordEdge(`1)">
      <requires>args != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.WeaklyConnectedComponentsAlgorithm`2.InternalCompute">
      <ensures>0 &lt;= this.ComponentCount &amp;&amp; this.ComponentCount &lt;= this.VisitedGraph.VertexCount</ensures>
      <ensures>Enumerable.All(this.VisitedGraph.Vertices,
                v =&gt; 0 &lt;= this.Components[v] &amp;&amp; this.Components[v] &lt; this.ComponentCount)</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.WeaklyConnectedComponentsAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},System.Collections.Generic.IDictionary{`0,System.Int32})">
      <requires>components != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.ConnectedComponentsAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IUndirectedGraph{`0,`1},System.Collections.Generic.IDictionary{`0,System.Int32})">
      <requires>components != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.StronglyConnectedComponentsAlgorithm`2.MinDiscoverTime(`0,`0)">
      <requires>u != null</requires>
      <requires>v != null</requires>
      <ensures>this.DiscoverTimes[u] &lt; this.DiscoverTimes[v] 
                ? Contract.Result&lt;TVertex&gt;().Equals(u) 
                : Contract.Result&lt;TVertex&gt;().Equals(v)</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.StronglyConnectedComponentsAlgorithm`2.InternalCompute">
      <ensures>this.ComponentCount &gt;= 0</ensures>
      <ensures>this.VisitedGraph.VertexCount == 0 || this.ComponentCount &gt; 0</ensures>
      <ensures>Enumerable.All(this.VisitedGraph.Vertices, v =&gt; this.Components.ContainsKey(v))</ensures>
      <ensures>this.VisitedGraph.VertexCount == this.Components.Count</ensures>
      <ensures>Enumerable.All(this.Components.Values, c =&gt; c &lt;= this.ComponentCount)</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.StronglyConnectedComponentsAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},System.Collections.Generic.IDictionary{`0,System.Int32})">
      <requires>components != null</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.IAlgorithm`1.VisitedGraph">
      <getter>
        <ensures>Contract.Result&lt;TGraph&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Algorithms.TarjanOfflineLeastCommonAncestorAlgorithm`2.SetVertexPairs(System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{`0}})">
      <requires>pairs != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.TarjanOfflineLeastCommonAncestorAlgorithm`2.Compute(`0,System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{`0}})">
      <requires>root != null</requires>
      <requires>pairs != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomGraphFactory.GetVertex``2(QuickGraph.IVertexListGraph{``0,``1},System.Random)">
      <requires>g != null</requires>
      <requires>rnd != null</requires>
      <requires>g.VertexCount &gt; 0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomGraphFactory.GetVertex``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Random)">
      <requires>vertices != null</requires>
      <requires>rnd != null</requires>
      <requires>count &gt; 0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomGraphFactory.Create``2(QuickGraph.IMutableVertexAndEdgeListGraph{``0,``1},QuickGraph.VertexFactory{``0},QuickGraph.EdgeFactory{``0,``1},System.Random,System.Int32,System.Int32,System.Boolean)">
      <requires>g != null</requires>
      <requires>vertexFactory != null</requires>
      <requires>edgeFactory != null</requires>
      <requires>rnd != null</requires>
      <requires>vertexCount &gt; 0</requires>
      <requires>edgeCount &gt;= 0</requires>
      <requires>
                !(!g.AllowParallelEdges &amp;&amp; !selfEdges) ||
                edgeCount &lt;= vertexCount * (vertexCount -1) // directed graph</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomGraphFactory.GetEdge``2(QuickGraph.IEdgeSet{``0,``1},System.Random)">
      <requires>g != null</requires>
      <requires>rnd != null</requires>
      <requires>g.EdgeCount &gt; 0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomGraphFactory.GetEdge``2(System.Collections.Generic.IEnumerable{``1},System.Int32,System.Random)">
      <requires>edges != null</requires>
      <requires>rnd != null</requires>
      <requires>count &gt; 0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomGraphFactory.Create``2(QuickGraph.IMutableUndirectedGraph{``0,``1},QuickGraph.VertexFactory{``0},QuickGraph.EdgeFactory{``0,``1},System.Random,System.Int32,System.Int32,System.Boolean)">
      <requires>g != null</requires>
      <requires>vertexFactory != null</requires>
      <requires>edgeFactory != null</requires>
      <requires>rnd != null</requires>
      <requires>vertexCount &gt; 0</requires>
      <requires>edgeCount &gt;= 0</requires>
      <requires>
                !(!g.AllowParallelEdges &amp;&amp; !selfEdges) ||
                edgeCount &lt;= vertexCount * (vertexCount - 1) / 2</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.DijkstraShortestPathAlgorithm`2.ComputeFromRoot(`0)">
      <requires>rootVertex != null</requires>
      <requires>this.VisitedGraph.ContainsVertex(rootVertex)</requires>
      <requires>this.VertexColors[rootVertex] == GraphColor.White</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedShortestPathAlgorithmBase`2.Relax(`1,`0,`0)">
      <requires>e != null</requires>
      <requires>source != null</requires>
      <requires>target != null</requires>
      <requires>
                (e.Source.Equals(source) &amp;&amp; e.Target.Equals(target))
                || (e.Source.Equals(target) &amp;&amp; e.Target.Equals(source))</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedShortestPathAlgorithmBase`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IUndirectedGraph{`0,`1},System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires>weights != null</requires>
      <requires>distanceRelaxer != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedShortestPathAlgorithmBase`2.TryGetDistance(`0,System.Double@)">
      <requires>vertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedDijkstraShortestPathAlgorithm`2.ComputeFromRoot(`0)">
      <requires>rootVertex != null</requires>
      <requires>this.VisitedGraph.ContainsVertex(rootVertex)</requires>
      <requires>this.VertexColors[rootVertex] == GraphColor.White</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedDijkstraShortestPathAlgorithm`2.ComputeNoInit(`0)">
      <requires>s != null</requires>
      <requires>this.VisitedGraph.ContainsVertex(s)</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedDijkstraShortestPathAlgorithm`2.InternalGrayTarget(System.Object,QuickGraph.UndirectedEdgeEventArgs{`0,`1})">
      <requires>args != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedDijkstraShortestPathAlgorithm`2.InternalTreeEdge(System.Object,QuickGraph.UndirectedEdgeEventArgs{`0,`1})">
      <requires>args != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.AStarShortestPathAlgorithm`2.ComputeFromRoot(`0)">
      <requires>rootVertex != null</requires>
      <requires>this.VisitedGraph.ContainsVertex(rootVertex)</requires>
      <requires>this.VertexColors[rootVertex] == GraphColor.White</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.AStarShortestPathAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},System.Func{`1,System.Double},System.Func{`0,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires>costHeuristic != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.ShortestPathAlgorithmBase`3.Relax(`1)">
      <requires>e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.ShortestPathAlgorithmBase`3.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,`2,System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires>weights != null</requires>
      <requires>distanceRelaxer != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.ShortestPathAlgorithmBase`3.TryGetDistance(`0,System.Double@)">
      <requires>vertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexAndEdgeListGraph{`0,`1},System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires>weights != null</requires>
      <requires>distanceRelaxer != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.#ctor(QuickGraph.IVertexAndEdgeListGraph{`0,`1},System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires>weights != null</requires>
      <requires>distanceRelaxer != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.TryGetDistance(`0,`0,System.Double@)">
      <requires>source != null</requires>
      <requires>target != null</requires>
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.VertexData">
      <invariant>!this.edgeStored || this._edge != null</invariant>
      <invariant>!this.predecessorStored || this._predecessor != null</invariant>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.VertexData.#ctor(System.Double,`1)">
      <requires>edge != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.VertexData.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.VertexData.#ctor(System.Double,`0)">
      <requires>predecessor != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.TryGetPath(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires>source != null</requires>
      <requires>target != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MinimumSpanningTree.KruskalMinimumSpanningTreeAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IUndirectedGraph{`0,`1},System.Func{`1,System.Double})">
      <requires>edgeWeights != null</requires>
    </member>
    <member name="M:QuickGraph.IMutableUndirectedGraph`2.ClearAdjacentEdges(`0)">
      <requires>vertex != null</requires>
      <ensures>ithis.AdjacentDegree(vertex) == 0</ensures>
    </member>
    <member name="M:QuickGraph.IMutableUndirectedGraph`2.RemoveAdjacentEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <requires>vertex != null</requires>
      <requires>predicate != null</requires>
      <ensures>Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.AdjacentEdges(vertex), e =&gt; predicate(e)))</ensures>
      <ensures>Enumerable.All(ithis.AdjacentEdges(vertex), v =&gt; !predicate(v))</ensures>
    </member>
    <member name="P:QuickGraph.DelegateUndirectedGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateUndirectedGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateUndirectedGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateUndirectedGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateUndirectedGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.DelegateUndirectedGraph`2.#ctor(System.Collections.Generic.IEnumerable{`0},QuickGraph.TryFunc{`0,System.Collections.Generic.IEnumerable{`1}},System.Boolean)">
      <requires>vertices != null</requires>
      <requires>Enumerable.All(vertices, v =&gt;
            {
                IEnumerable&lt;TEdge&gt; edges;
                return tryGetAdjacentEdges(v, out edges);
            })</requires>
    </member>
    <member name="P:QuickGraph.DelegateUndirectedGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.DelegateUndirectedGraph`2.ContainsEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)">
      <requires>v != null</requires>
      <ensures>Contract.Result&lt;bool&gt;() == Contract.OldValue(ithis.ContainsVertex(v))</ensures>
      <ensures>!ithis.ContainsVertex(v)</ensures>
      <ensures>ithis.VertexCount == Contract.OldValue(ithis.VertexCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)">
      <requires>v != null</requires>
      <ensures>Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsVertex(v))</ensures>
      <ensures>ithis.ContainsVertex(v)</ensures>
      <ensures>ithis.VertexCount == Contract.OldValue(ithis.VertexCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})">
      <requires>vertices != null</requires>
      <requires>Enumerable.All(vertices, v =&gt; v != null)</requires>
      <ensures>Enumerable.All(vertices, v =&gt; ithis.ContainsVertex(v))</ensures>
      <ensures>ithis.VertexCount == Contract.OldValue(ithis.VertexCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})">
      <requires>pred != null</requires>
      <ensures>Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.Vertices, v =&gt; pred(v)))</ensures>
      <ensures>Enumerable.All(ithis.Vertices, v =&gt; !pred(v))</ensures>
      <ensures>ithis.VertexCount == Contract.OldValue(ithis.VertexCount) - Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="T:QuickGraph.UndirectedGraph`2">
      <invariant>this.edgeCount &gt;= 0</invariant>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.ContainsEdgeBetweenVertices(System.Collections.Generic.IEnumerable{`1},`1)">
      <requires>edges != null</requires>
      <requires>edge != null</requires>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AdjacentDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.AdjacentEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.RemoveVertexIf(QuickGraph.VertexPredicate{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet">pred != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet">Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.Vertices, v =&gt; pred(v)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet">Enumerable.All(ithis.Vertices, v =&gt; !pred(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet">ithis.VertexCount == Contract.OldValue(ithis.VertexCount) - Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">predicate != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.Edges, e =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(ithis.Edges, e =&gt; !predicate(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.RemoveVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet">Contract.Result&lt;bool&gt;() == Contract.OldValue(ithis.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet">!ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet">ithis.VertexCount == Contract.OldValue(ithis.VertexCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.OnVertexRemoved(`0)">
      <requires>args != null</requires>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AddVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet">Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet">ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet">ithis.VertexCount == Contract.OldValue(ithis.VertexCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet">typeof(TEdge).IsValueType || Enumerable.All(edges, edge =&gt; edge != null)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">typeof(TEdge).IsValueType || Enumerable.All(edges, edge =&gt; edge != null)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(edges, edge =&gt;
                ithis.ContainsVertex(edge.Source) &amp;&amp;
                ithis.ContainsVertex(edge.Target)
                )</requires>
      <ensures description="all edge from edges belong to the graph" inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(edges, edge =&gt; ithis.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">
                Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(edges, edge =&gt; !ithis.ContainsEdge(edge)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.RemoveEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">e != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">Contract.Result&lt;bool&gt;() == Contract.OldValue(ithis.ContainsEdge(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">!ithis.ContainsEdge(e)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AddEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">e != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsVertex(e.Source)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsVertex(e.Target)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsEdge(e)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsEdge(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AdjacentEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">
                Enumerable.All(
                    Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(),
                    edge =&gt; 
                        edge != null &amp;&amp; 
                        ithis.ContainsEdge(edge.Source, edge.Target) &amp;&amp; 
                        (edge.Source.Equals(v) || edge.Target.Equals(v))
                    )</ensures>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.OnVertexAdded(`0)">
      <requires>args != null</requires>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.IsAdjacentEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;bool&gt;() == (ithis.AdjacentDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph">target != null</requires>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.EdgeEqualityComparer">
      <getter>
        <ensures>Contract.Result&lt;EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.get_EdgeEqualityComparer" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.#ctor(System.Boolean,QuickGraph.EdgeEqualityComparer{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <requires>edgeEqualityComparer != null</requires>
      <requires>vertexComparer != null</requires>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AddVerticesAndEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet">ithis.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet">ithis.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.ClearAdjacentEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableUndirectedGraph`2.ClearAdjacentEdges(`0)" inheritedFromTypeName="IMutableUndirectedGraph">vertex != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableUndirectedGraph`2.ClearAdjacentEdges(`0)" inheritedFromTypeName="IMutableUndirectedGraph">ithis.AdjacentDegree(vertex) == 0</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.RemoveAdjacentEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableUndirectedGraph`2.RemoveAdjacentEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableUndirectedGraph">vertex != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableUndirectedGraph`2.RemoveAdjacentEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableUndirectedGraph">predicate != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableUndirectedGraph`2.RemoveAdjacentEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableUndirectedGraph">Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.AdjacentEdges(vertex), e =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableUndirectedGraph`2.RemoveAdjacentEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableUndirectedGraph">Enumerable.All(ithis.AdjacentEdges(vertex), v =&gt; !predicate(v))</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AddVertexRange(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet">vertices != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet">Enumerable.All(vertices, v =&gt; v != null)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet">Enumerable.All(vertices, v =&gt; ithis.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet">ithis.VertexCount == Contract.OldValue(ithis.VertexCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">target != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;bool&gt;() == Enumerable.Any(ithis.AdjacentEdges(source), e =&gt; e.Target.Equals(target) || e.Source.Equals(target))</ensures>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.ContainsEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AdjacentEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;TEdge&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">
                Contract.Result&lt;TEdge&gt;().Source.Equals(v)
                || Contract.Result&lt;TEdge&gt;().Target.Equals(v)</ensures>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.RemoveEdgeIf(QuickGraph.EdgePredicate{System.Int32,`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">predicate != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.Edges, e =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(ithis.Edges, e =&gt; !predicate(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.TryGetEdge(System.Int32,System.Int32,`0@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="P:QuickGraph.BidirectionalMatrixGraph`1.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalMatrixGraph`1.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.ContainsVertex(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.RemoveInEdgeIf(System.Int32,QuickGraph.EdgePredicate{System.Int32,`0})">
      <requires>0 &lt;= v &amp;&amp; v &lt; this.VertexCount</requires>
    </member>
    <member name="P:QuickGraph.BidirectionalMatrixGraph`1.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.ContainsEdge(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.RemoveOutEdgeIf(System.Int32,QuickGraph.EdgePredicate{System.Int32,`0})">
      <requires>0 &lt;= v &amp;&amp; v &lt; this.VertexCount</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.#ctor(System.Int32,System.Int32,`0[0:,0:])">
      <requires>vertexCount &gt; 0</requires>
      <requires>edgeCount &gt;= 0</requires>
      <requires>edges != null</requires>
      <requires>vertexCount == edges.GetLength(0)</requires>
      <requires>vertexCount == edges.GetLength(1)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.InDegree(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.InEdges(v))</ensures>
    </member>
    <member name="P:QuickGraph.BidirectionalMatrixGraph`1.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.Degree(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == ithis.InDegree(v) + ithis.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.ClearEdges(System.Int32)">
      <requires>0 &lt;= v &amp;&amp; v &lt; this.VertexCount</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.TryGetEdges(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{`0}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.OutEdge(System.Int32,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">
                Enumerable.ElementAt(ithis.OutEdges(v), index).Equals(Contract.Result&lt;TEdge&gt;())</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.ClearOutEdges(System.Int32)">
      <requires>0 &lt;= v &amp;&amp; v &lt; this.VertexCount</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.AddEdgeRange(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">typeof(TEdge).IsValueType || Enumerable.All(edges, edge =&gt; edge != null)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(edges, edge =&gt;
                ithis.ContainsVertex(edge.Source) &amp;&amp;
                ithis.ContainsVertex(edge.Target)
                )</requires>
      <ensures description="all edge from edges belong to the graph" inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(edges, edge =&gt; ithis.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">
                Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(edges, edge =&gt; !ithis.ContainsEdge(edge)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="P:QuickGraph.BidirectionalMatrixGraph`1.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.AddEdge(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">e != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsVertex(e.Source)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsVertex(e.Target)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsEdge(e)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsEdge(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="P:QuickGraph.BidirectionalMatrixGraph`1.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.TryGetOutEdges(System.Int32,System.Collections.Generic.IEnumerable{`0}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">!Contract.Result&lt;bool&gt;() || 
                (Contract.ValueAtReturn(out edges) != null &amp;&amp; 
                 Enumerable.All(Contract.ValueAtReturn(out edges), e =&gt; e.Source.Equals(v)))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.RemoveEdge(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">e != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">Contract.Result&lt;bool&gt;() == Contract.OldValue(ithis.ContainsEdge(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">!ithis.ContainsEdge(e)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.ContainsEdge(System.Int32,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.OutEdges(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Enumerable.All(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e.Source.Equals(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.TryGetInEdges(System.Int32,System.Collections.Generic.IEnumerable{`0}@)">
      <pure />
      <ensures>Contract.Result&lt;bool&gt;() == (0 &lt;= 0 &amp;&amp; v &gt; this.VertexCount)</ensures>
      <ensures>
                Contract.Result&lt;bool&gt;() == 
                (Contract.ValueAtReturn&lt;IEnumerable&lt;TEdge&gt;&gt;(out edges) != null)</ensures>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || Contract.ValueAtReturn(out edges) != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || 
                Enumerable.All(
                Contract.ValueAtReturn&lt;IEnumerable&lt;TEdge&gt;&gt;(out edges),
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.OutDegree(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;int&gt;() == Enumerable.Count&lt;TEdge&gt;(ithis.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.IsInEdgesEmpty(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == (ithis.InDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.#ctor(System.Int32)">
      <requires>vertexCount &gt; 0</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.InEdge(System.Int32,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;TEdge&gt;().Equals(Enumerable.ElementAt(ithis.InEdges(v), index))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.ClearInEdges(System.Int32)">
      <requires>0 &lt;= v &amp;&amp; v &lt; this.VertexCount</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.InEdges(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Enumerable.All(
                Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), 
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.IsOutEdgesEmpty(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;bool&gt;() == (ithis.OutDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="P:QuickGraph.ArrayBidirectionalGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.ContainsVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="P:QuickGraph.ArrayBidirectionalGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.ContainsEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.InEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Enumerable.All(
                Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), 
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="P:QuickGraph.ArrayBidirectionalGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.InDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.Degree(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == ithis.InDegree(v) + ithis.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.OutEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">
                Enumerable.ElementAt(ithis.OutEdges(v), index).Equals(Contract.Result&lt;TEdge&gt;())</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.OutDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;int&gt;() == Enumerable.Count&lt;TEdge&gt;(ithis.OutEdges(v))</ensures>
    </member>
    <member name="P:QuickGraph.ArrayBidirectionalGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.IsInEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == (ithis.InDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">!Contract.Result&lt;bool&gt;() || 
                (Contract.ValueAtReturn(out edges) != null &amp;&amp; 
                 Enumerable.All(Contract.ValueAtReturn(out edges), e =&gt; e.Source.Equals(v)))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.OutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Enumerable.All(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e.Source.Equals(v))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || Contract.ValueAtReturn(out edges) != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || 
                Enumerable.All(
                Contract.ValueAtReturn&lt;IEnumerable&lt;TEdge&gt;&gt;(out edges),
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="P:QuickGraph.ArrayBidirectionalGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.#ctor(System.Collections.Generic.Dictionary{`0,QuickGraph.ArrayBidirectionalGraph{`0,`1}.InOutEdges},System.Int32)">
      <requires>vertexEdges != null</requires>
      <requires>edgeCount &gt;= 0</requires>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.InEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;TEdge&gt;().Equals(Enumerable.ElementAt(ithis.InEdges(v), index))</ensures>
    </member>
    <member name="P:QuickGraph.ArrayBidirectionalGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.IsOutEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;bool&gt;() == (ithis.OutDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.IsOutEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;bool&gt;() == (ithis.OutDegree(v) == 0)</ensures>
    </member>
    <member name="P:QuickGraph.ArrayAdjacencyGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.#ctor(System.Collections.Generic.Dictionary{`0,`1[]},System.Int32)">
      <requires>vertexOutEdges != null</requires>
      <requires>edgeCount &gt;= 0</requires>
      <requires>edgeCount == Enumerable.Sum(vertexOutEdges, kv =&gt; (kv.Value == null) ? 0 : kv.Value.Length)</requires>
    </member>
    <member name="P:QuickGraph.ArrayAdjacencyGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.OutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Enumerable.All(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e.Source.Equals(v))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.ContainsVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.OutDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;int&gt;() == Enumerable.Count&lt;TEdge&gt;(ithis.OutEdges(v))</ensures>
    </member>
    <member name="P:QuickGraph.ArrayAdjacencyGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.ContainsEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="P:QuickGraph.ArrayAdjacencyGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.#ctor(QuickGraph.IVertexAndEdgeListGraph{`0,`1})">
      <requires>visitedGraph != null</requires>
    </member>
    <member name="P:QuickGraph.ArrayAdjacencyGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayAdjacencyGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">!Contract.Result&lt;bool&gt;() || 
                (Contract.ValueAtReturn(out edges) != null &amp;&amp; 
                 Enumerable.All(Contract.ValueAtReturn(out edges), e =&gt; e.Source.Equals(v)))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.OutEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">
                Enumerable.ElementAt(ithis.OutEdges(v), index).Equals(Contract.Result&lt;TEdge&gt;())</ensures>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="P:QuickGraph.DelegateVertexAndEdgeListGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateVertexAndEdgeListGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateVertexAndEdgeListGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateVertexAndEdgeListGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateVertexAndEdgeListGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.DelegateVertexAndEdgeListGraph`2.#ctor(System.Collections.Generic.IEnumerable{`0},QuickGraph.TryFunc{`0,System.Collections.Generic.IEnumerable{`1}})">
      <requires>vertices != null</requires>
      <requires>Enumerable.All(vertices, v =&gt;
            {
                IEnumerable&lt;TEdge&gt; edges;
                return tryGetOutEdges(v, out edges);
            })</requires>
    </member>
    <member name="P:QuickGraph.DelegateVertexAndEdgeListGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.DelegateVertexAndEdgeListGraph`2.ContainsEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="T:QuickGraph.Collections.SoftHeap`2">
      <invariant>this.count &gt; -1</invariant>
      <invariant>this.header != null</invariant>
      <invariant>this.tail != null</invariant>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.Enumerator.#ctor(QuickGraph.Collections.SoftHeap{`0,`1})">
      <requires>owner != null</requires>
    </member>
    <member name="P:QuickGraph.Collections.SoftHeap`2.Enumerator.System#Collections#IEnumerator#Current">
      <getter>
        <ensures inheritedFrom="M:System.Collections.IEnumerator.get_Current" inheritedFromTypeName="IEnumerator">Contract.Result&lt;object&gt;() == this.Model[this.CurrentIndex]</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Collections.SoftHeap`2.Enumerator.Current">
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IEnumerator`1.get_Current" inheritedFromTypeName="IEnumerator">(object)Contract.Result&lt;T&gt;() == this.Model[this.CurrentIndex]</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.Enumerator.MoveNext">
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.Model == Contract.OldValue(this.Model)</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.CurrentIndex &lt; this.Model.Length</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.CurrentIndex &gt;= 0</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.CurrentIndex == Contract.OldValue(this.CurrentIndex) + 1</ensures>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.Enumerator.System#Collections#IEnumerator#get_Current">
      <ensures inheritedFrom="M:System.Collections.IEnumerator.get_Current" inheritedFromTypeName="IEnumerator">Contract.Result&lt;object&gt;() == this.Model[this.CurrentIndex]</ensures>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.Meld(QuickGraph.Collections.SoftHeap{`0,`1}.Node)">
      <requires>q != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.Add(`0,`1)">
      <requires>this.Comparison(key, this.KeyMaxValue) &lt; 0</requires>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.FixMinLinst(QuickGraph.Collections.SoftHeap{`0,`1}.Head)">
      <requires>h != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.Shift(QuickGraph.Collections.SoftHeap{`0,`1}.Node)">
      <requires>v != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.#ctor(System.Double,`0,System.Func{`0,`0,System.Int32})">
      <requires>comparison != null</requires>
      <requires>0 &lt; maximumErrorRate &amp;&amp; maximumErrorRate &lt;= 0.5</requires>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.FindNoCompression(QuickGraph.Collections.ForestDisjointSet{`0}.Element)">
      <pure />
      <requires>element != null</requires>
      <ensures>Contract.Result&lt;Element&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.Union(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.Union(`0,`0)" inheritedFromTypeName="IDisjointSet">left != null</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.Union(`0,`0)" inheritedFromTypeName="IDisjointSet">ithis.Contains(left)</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.Union(`0,`0)" inheritedFromTypeName="IDisjointSet">right != null</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.Union(`0,`0)" inheritedFromTypeName="IDisjointSet">ithis.Contains(right)</requires>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.CompressPath(QuickGraph.Collections.ForestDisjointSet{`0}.Element,QuickGraph.Collections.ForestDisjointSet{`0}.Element)">
      <requires>element != null</requires>
      <requires>root != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.#ctor(System.Int32)">
      <requires>elementCapacity &gt;= 0 &amp;&amp; elementCapacity &lt; int.MaxValue</requires>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.FindSet(`0)">
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.FindSet(`0)" inheritedFromTypeName="IDisjointSet">value != null</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.FindSet(`0)" inheritedFromTypeName="IDisjointSet">ithis.Contains(value)</requires>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.AreInSameSet(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.AreInSameSet(`0,`0)" inheritedFromTypeName="IDisjointSet">left != null</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.AreInSameSet(`0,`0)" inheritedFromTypeName="IDisjointSet">right != null</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.AreInSameSet(`0,`0)" inheritedFromTypeName="IDisjointSet">ithis.Contains(left)</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.AreInSameSet(`0,`0)" inheritedFromTypeName="IDisjointSet">ithis.Contains(right)</requires>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.Union(QuickGraph.Collections.ForestDisjointSet{`0}.Element,QuickGraph.Collections.ForestDisjointSet{`0}.Element)">
      <requires>left != null</requires>
      <requires>right != null</requires>
      <ensures>
                Contract.Result&lt;bool&gt;() 
                ? Contract.OldValue(this.SetCount) - 1 == this.SetCount             
                : Contract.OldValue(this.SetCount) == this.SetCount</ensures>
      <ensures>this.FindNoCompression(left) == this.FindNoCompression(right)</ensures>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.Contains(`0)">
      <pure />
    </member>
    <member name="M:QuickGraph.Collections.EdgeList`2.QuickGraph#Collections#IEdgeList{TVertex@TEdge}#Clone">
      <ensures inheritedFrom="M:QuickGraph.Collections.IEdgeList`2.Clone" inheritedFromTypeName="IEdgeList">Contract.Result&lt;IEdgeList&lt;TVertex, TEdge&gt;&gt;() != null</ensures>
    </member>
    <member name="P:QuickGraph.Collections.FibonacciQueue`2.Count">
      <getter>
        <pure />
      </getter>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciQueue`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1},System.Func{`1,`1,System.Int32})">
      <requires>valueCount &gt;= 0</requires>
      <requires>valueCount == 0 || (values != null &amp;&amp; valueCount == Enumerable.Count(values))</requires>
      <requires>distances != null</requires>
      <requires>distanceComparison != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciQueue`2.#ctor(System.Collections.Generic.Dictionary{`0,`1},System.Func{`1,`1,System.Int32})">
      <requires>values != null</requires>
      <requires>distanceComparison != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciQueue`2.Contains(`0)">
      <pure />
    </member>
    <member name="M:QuickGraph.Collections.FibonacciQueue`2.ToArray">
      <pure />
    </member>
    <member name="M:QuickGraph.Collections.BinaryHeap`2.Swap(System.Int32,System.Int32)">
      <requires>
                i &gt;= 0 &amp;&amp; i &lt; this.count &amp;&amp;
                j &gt;= 0 &amp;&amp; j &lt; this.count &amp;&amp;
                i != j</requires>
    </member>
    <member name="M:QuickGraph.Collections.BinaryHeap`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="P:QuickGraph.Collections.BinaryHeap`2.Enumerator.System#Collections#IEnumerator#Current">
      <getter>
        <ensures inheritedFrom="M:System.Collections.IEnumerator.get_Current" inheritedFromTypeName="IEnumerator">Contract.Result&lt;object&gt;() == this.Model[this.CurrentIndex]</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Collections.BinaryHeap`2.Enumerator.Current">
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IEnumerator`1.get_Current" inheritedFromTypeName="IEnumerator">(object)Contract.Result&lt;T&gt;() == this.Model[this.CurrentIndex]</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Collections.BinaryHeap`2.Enumerator.MoveNext">
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.Model == Contract.OldValue(this.Model)</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.CurrentIndex &lt; this.Model.Length</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.CurrentIndex &gt;= 0</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.CurrentIndex == Contract.OldValue(this.CurrentIndex) + 1</ensures>
    </member>
    <member name="M:QuickGraph.Collections.BinaryHeap`2.Enumerator.System#Collections#IEnumerator#get_Current">
      <ensures inheritedFrom="M:System.Collections.IEnumerator.get_Current" inheritedFromTypeName="IEnumerator">Contract.Result&lt;object&gt;() == this.Model[this.CurrentIndex]</ensures>
    </member>
    <member name="M:QuickGraph.Collections.BinaryHeap`2.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:QuickGraph.Collections.BinaryHeap`2.Less(System.Int32,System.Int32)">
      <pure />
      <requires>
                i &gt;= 0 &amp; i &lt; this.count &amp;
                j &gt;= 0 &amp; j &lt; this.count &amp;
                i != j</requires>
    </member>
    <member name="M:QuickGraph.Collections.BinaryHeap`2.#ctor(System.Int32,System.Func{`0,`0,System.Int32})">
      <requires>capacity &gt;= 0</requires>
      <requires>priorityComparison != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeapLinkedList`2.MergeLists(QuickGraph.Collections.FibonacciHeapLinkedList{`0,`1})">
      <requires>list != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeapLinkedList`2.Remove(QuickGraph.Collections.FibonacciHeapCell{`0,`1})">
      <requires>node != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeapLinkedList`2.AddLast(QuickGraph.Collections.FibonacciHeapCell{`0,`1})">
      <requires>node != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeapLinkedList`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeapLinkedList`2.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.ChangeKeyInternal(QuickGraph.Collections.FibonacciHeapCell{`0,`1},`0,System.Boolean)">
      <requires>node != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
      <requires>values != null</requires>
      <requires>converter != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.Delete(QuickGraph.Collections.FibonacciHeapCell{`0,`1})">
      <requires>node != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.ChangeKey(QuickGraph.Collections.FibonacciHeapCell{`0,`1},`0)">
      <requires>node != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.Merge(QuickGraph.Collections.FibonacciHeap{`0,`1})">
      <requires>other != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.VertexEdgeDictionary`2.QuickGraph#Collections#IVertexEdgeDictionary{TVertex@TEdge}#Clone">
      <ensures inheritedFrom="M:QuickGraph.Collections.IVertexEdgeDictionary`2.Clone" inheritedFromTypeName="IVertexEdgeDictionary">Contract.Result&lt;IVertexEdgeDictionary&lt;TVertex, TEdge&gt;&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.Collections.BinaryQueue`2.#ctor(System.Func{`0,`1},System.Func{`1,`1,System.Int32})">
      <requires>distances != null</requires>
      <requires>distanceComparison != null</requires>
    </member>
    <member name="P:QuickGraph.EdgeListGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">predicate != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.Edges, e =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(ithis.Edges, e =&gt; !predicate(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="P:QuickGraph.EdgeListGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.#ctor(System.Boolean,System.Boolean,QuickGraph.Collections.EdgeEdgeDictionary{`0,`1})">
      <requires>edges != null</requires>
    </member>
    <member name="P:QuickGraph.EdgeListGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">typeof(TEdge).IsValueType || Enumerable.All(edges, edge =&gt; edge != null)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(edges, edge =&gt;
                ithis.ContainsVertex(edge.Source) &amp;&amp;
                ithis.ContainsVertex(edge.Target)
                )</requires>
      <ensures description="all edge from edges belong to the graph" inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(edges, edge =&gt; ithis.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">
                Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(edges, edge =&gt; !ithis.ContainsEdge(edge)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.RemoveEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">e != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">Contract.Result&lt;bool&gt;() == Contract.OldValue(ithis.ContainsEdge(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">!ithis.ContainsEdge(e)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="P:QuickGraph.EdgeListGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.EdgeListGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.AddEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">e != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsVertex(e.Source)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsVertex(e.Target)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.ContainsEdge(e)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsEdge(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="P:QuickGraph.EdgeListGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.STaggedEquatableEdge`2.Target">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.STaggedEquatableEdge`2.#ctor(`0,`0,`1)">
      <requires>source != null</requires>
      <requires>target != null</requires>
    </member>
    <member name="P:QuickGraph.STaggedEquatableEdge`2.Source">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.SReversedEdge`2.Source">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.SReversedEdge`2.Equals(QuickGraph.SReversedEdge{`0,`1})">
      <pure />
    </member>
    <member name="P:QuickGraph.SReversedEdge`2.Target">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge">Contract.Result&lt;TVertex&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.SReversedEdge`2.#ctor(`1)">
      <requires>originalEdge != null</requires>
    </member>
    <member name="M:QuickGraph.SReversedEdge`2.Equals(System.Object)">
      <pure />
    </member>
    <member name="M:QuickGraph.SReversedEdge`2.ToString">
      <pure />
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:QuickGraph.SReversedEdge`2.GetHashCode">
      <pure />
    </member>
    <member name="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)">
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>Contract.Result&lt;bool&gt;() == (ithis.AdjacentDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)">
      <pure />
      <requires>source != null</requires>
      <requires>target != null</requires>
    </member>
    <member name="P:QuickGraph.IImplicitUndirectedGraph`2.EdgeEqualityComparer">
      <getter>
        <ensures>Contract.Result&lt;EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)">
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures>
                Enumerable.All(
                    Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(),
                    edge =&gt; 
                        edge != null &amp;&amp; 
                        ithis.ContainsEdge(edge.Source, edge.Target) &amp;&amp; 
                        (edge.Source.Equals(v) || edge.Target.Equals(v))
                    )</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)">
      <pure />
      <requires>source != null</requires>
      <requires>target != null</requires>
      <ensures>Contract.Result&lt;bool&gt;() == Enumerable.Any(ithis.AdjacentEdges(source), e =&gt; e.Target.Equals(target) || e.Source.Equals(target))</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)">
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>Contract.Result&lt;TEdge&gt;() != null</ensures>
      <ensures>
                Contract.Result&lt;TEdge&gt;().Source.Equals(v)
                || Contract.Result&lt;TEdge&gt;().Target.Equals(v)</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)">
      <pure />
      <requires>v != null</requires>
      <requires>ithis.ContainsVertex(v)</requires>
      <ensures>Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.AdjacentEdges(v))</ensures>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph">target != null</requires>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.EdgeEqualityComparer">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.get_EdgeEqualityComparer" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.ContainsEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.ContainsVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.AdjacentDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.AdjacentEdges(v))</ensures>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.AdjacentEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">
                Enumerable.All(
                    Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(),
                    edge =&gt; 
                        edge != null &amp;&amp; 
                        ithis.ContainsEdge(edge.Source, edge.Target) &amp;&amp; 
                        (edge.Source.Equals(v) || edge.Target.Equals(v))
                    )</ensures>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.#ctor(QuickGraph.IUndirectedGraph{`0,`1})">
      <requires>graph != null</requires>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">target != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;bool&gt;() == Enumerable.Any(ithis.AdjacentEdges(source), e =&gt; e.Target.Equals(target) || e.Source.Equals(target))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.AdjacentEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;TEdge&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">
                Contract.Result&lt;TEdge&gt;().Source.Equals(v)
                || Contract.Result&lt;TEdge&gt;().Target.Equals(v)</ensures>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;bool&gt;() == (ithis.AdjacentDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.RemoveVertexIf(QuickGraph.VertexPredicate{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet">pred != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet">Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.Vertices, v =&gt; pred(v)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet">Enumerable.All(ithis.Vertices, v =&gt; !pred(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet">ithis.VertexCount == Contract.OldValue(ithis.VertexCount) - Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">predicate != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.Edges, e =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(ithis.Edges, e =&gt; !predicate(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.RemoveVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet">Contract.Result&lt;bool&gt;() == Contract.OldValue(ithis.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet">!ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet">ithis.VertexCount == Contract.OldValue(ithis.VertexCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.OnVertexRemoved(`0)">
      <requires>args != null</requires>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.AddVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet">Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet">ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet">ithis.VertexCount == Contract.OldValue(ithis.VertexCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">typeof(TEdge).IsValueType || Enumerable.All(edges, edge =&gt; edge != null)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(edges, edge =&gt;
                ithis.ContainsVertex(edge.Source) &amp;&amp;
                ithis.ContainsVertex(edge.Target)
                )</requires>
      <ensures description="all edge from edges belong to the graph" inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">Enumerable.All(edges, edge =&gt; ithis.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">
                Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(edges, edge =&gt; !ithis.ContainsEdge(edge)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">!Contract.Result&lt;bool&gt;() || 
                (Contract.ValueAtReturn(out edges) != null &amp;&amp; 
                 Enumerable.All(Contract.ValueAtReturn(out edges), e =&gt; e.Source.Equals(v)))</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.RemoveEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">e != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">Contract.Result&lt;bool&gt;() == Contract.OldValue(ithis.ContainsEdge(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">!ithis.ContainsEdge(e)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.OutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Enumerable.All(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e.Source.Equals(v))</ensures>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.OnVertexAdded(`0)">
      <requires>args != null</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.IsOutEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;bool&gt;() == (ithis.OutDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.OutEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">
                Enumerable.ElementAt(ithis.OutEdges(v), index).Equals(Contract.Result&lt;TEdge&gt;())</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.TryGetEdge(`0,`0,`1@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.AllowParallelEdges">
      <getter>
        <pure />
      </getter>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.#ctor(System.Boolean,System.Int32,System.Int32,System.Func{System.Int32,QuickGraph.Collections.IVertexEdgeDictionary{`0,`1}})">
      <requires>vertexEdgesDictionaryFactory != null</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.Clone">
      <pure />
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.AddVerticesAndEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet">ithis.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet">ithis.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.OldValue(!ithis.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet">ithis.EdgeCount == Contract.OldValue(ithis.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph">predicate != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph">Contract.Result&lt;int&gt;() == Contract.OldValue(Enumerable.Count(ithis.OutEdges(v), ve =&gt; predicate(ve)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph">Enumerable.All(ithis.OutEdges(v), ve =&gt; !predicate(ve))</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.#ctor(System.Boolean,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <requires>vertexComparer != null</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.AddVertexRange(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet">vertices != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet">Enumerable.All(vertices, v =&gt; v != null)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet">Enumerable.All(vertices, v =&gt; ithis.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet">ithis.VertexCount == Contract.OldValue(ithis.VertexCount) + Contract.Result&lt;int&gt;()</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.ContainsEdge(`0,`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.OutDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;int&gt;() == Enumerable.Count&lt;TEdge&gt;(ithis.OutEdges(v))</ensures>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.#ctor(QuickGraph.Collections.IVertexEdgeDictionary{`0,`1},System.Int32,System.Int32,System.Boolean)">
      <requires>vertexEdges != null</requires>
      <requires>edgeCount &gt;= 0</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.ClearOutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)" inheritedFromTypeName="IMutableIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)" inheritedFromTypeName="IMutableIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)" inheritedFromTypeName="IMutableIncidenceGraph">ithis.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.#ctor(QuickGraph.TryFunc{`0,System.Collections.Generic.IEnumerable{`1}})">
      <requires>tryGetOutEdges != null</requires>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">!Contract.Result&lt;bool&gt;() || 
                (Contract.ValueAtReturn(out edges) != null &amp;&amp; 
                 Enumerable.All(Contract.ValueAtReturn(out edges), e =&gt; e.Source.Equals(v)))</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.IsOutEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;bool&gt;() == (ithis.OutDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.OutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Enumerable.All(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e.Source.Equals(v))</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.ContainsVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.OutDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;int&gt;() == Enumerable.Count&lt;TEdge&gt;(ithis.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.OutEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">
                Enumerable.ElementAt(ithis.OutEdges(v), index).Equals(Contract.Result&lt;TEdge&gt;())</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;bool&gt;() == (ithis.AdjacentDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph">target != null</requires>
    </member>
    <member name="P:QuickGraph.DelegateImplicitUndirectedGraph`2.EdgeEqualityComparer">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.get_EdgeEqualityComparer" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">target != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;bool&gt;() == Enumerable.Any(ithis.AdjacentEdges(source), e =&gt; e.Target.Equals(target) || e.Source.Equals(target))</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.ContainsVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.AdjacentDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.AdjacentEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.AdjacentEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">
                Enumerable.All(
                    Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(),
                    edge =&gt; 
                        edge != null &amp;&amp; 
                        ithis.ContainsEdge(edge.Source, edge.Target) &amp;&amp; 
                        (edge.Source.Equals(v) || edge.Target.Equals(v))
                    )</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.#ctor(QuickGraph.TryFunc{`0,System.Collections.Generic.IEnumerable{`1}},System.Boolean)">
      <requires>tryGetAdjacenyEdges != null</requires>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;TEdge&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">
                Contract.Result&lt;TEdge&gt;().Source.Equals(v)
                || Contract.Result&lt;TEdge&gt;().Target.Equals(v)</ensures>
    </member>
    <member name="M:QuickGraph.TaggedEdge`2.#ctor(`0,`0,`1)">
      <ensures>Object.Equals(this.Tag,tag)</ensures>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph">target != null</requires>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.EdgeEqualityComparer">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.get_EdgeEqualityComparer" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.ContainsEdge(`0,`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">target != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;bool&gt;() == Enumerable.Any(ithis.AdjacentEdges(source), e =&gt; e.Target.Equals(target) || e.Source.Equals(target))</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.AdjacentDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.AdjacentEdges(v))</ensures>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.AdjacentEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">
                Enumerable.All(
                    Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(),
                    edge =&gt; 
                        edge != null &amp;&amp; 
                        ithis.ContainsEdge(edge.Source, edge.Target) &amp;&amp; 
                        (edge.Source.Equals(v) || edge.Target.Equals(v))
                    )</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.#ctor(QuickGraph.IBidirectionalGraph{`0,`1})">
      <requires>visitedGraph != null</requires>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.AdjacentEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;TEdge&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">
                Contract.Result&lt;TEdge&gt;().Source.Equals(v)
                || Contract.Result&lt;TEdge&gt;().Target.Equals(v)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.IsAdjacentEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;bool&gt;() == (ithis.AdjacentDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.EnumerableContract.All(System.Int32,System.Int32,System.Func{System.Int32,System.Boolean})">
      <pure />
    </member>
    <member name="M:QuickGraph.EnumerableContract.ElementsNotNull``1(System.Collections.Generic.IEnumerable{``0})">
      <pure />
      <requires>elements != null</requires>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredVertexAndEdgeListGraph`3.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredVertexAndEdgeListGraph`3.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredVertexAndEdgeListGraph`3.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredVertexAndEdgeListGraph`3.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.InDictionaryVertexPredicate`2.Test(`0)">
      <pure />
      <requires>v != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.InDictionaryVertexPredicate`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <requires>dictionary != null</requires>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredVertexListGraph`3.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredVertexListGraph`3.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredVertexListGraph`3.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredIncidenceGraph`3.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredIncidenceGraph`3.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredIncidenceGraph`3.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph">ithis.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.Predicates.ResidualEdgePredicate`2.Test(`1)">
      <requires>e != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.ResidualEdgePredicate`2.#ctor(System.Collections.Generic.IDictionary{`1,System.Double})">
      <requires>residualCapacities != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.SinkVertexPredicate`2.#ctor(QuickGraph.IIncidenceGraph{`0,`1})">
      <requires>visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredImplicitGraph`3.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph">!Contract.Result&lt;bool&gt;() || 
                (Contract.ValueAtReturn(out edges) != null &amp;&amp; 
                 Enumerable.All(Contract.ValueAtReturn(out edges), e =&gt; e.Source.Equals(v)))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredImplicitGraph`3.IsOutEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;bool&gt;() == (ithis.OutDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredImplicitGraph`3.OutEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph">Enumerable.All(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e.Source.Equals(v))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredImplicitGraph`3.OutDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph">Contract.Result&lt;int&gt;() == Enumerable.Count&lt;TEdge&gt;(ithis.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredImplicitGraph`3.OutEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph">
                Enumerable.ElementAt(ithis.OutEdges(v), index).Equals(Contract.Result&lt;TEdge&gt;())</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph">target != null</requires>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.EdgeEqualityComparer">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.get_EdgeEqualityComparer" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.AdjacentDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.AdjacentEdges(v))</ensures>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.AdjacentEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">
                Enumerable.All(
                    Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(),
                    edge =&gt; 
                        edge != null &amp;&amp; 
                        ithis.ContainsEdge(edge.Source, edge.Target) &amp;&amp; 
                        (edge.Source.Equals(v) || edge.Target.Equals(v))
                    )</ensures>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.ContainsEdge(`0,`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">source != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">target != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;bool&gt;() == Enumerable.Any(ithis.AdjacentEdges(source), e =&gt; e.Target.Equals(target) || e.Source.Equals(target))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.AdjacentEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;TEdge&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph">
                Contract.Result&lt;TEdge&gt;().Source.Equals(v)
                || Contract.Result&lt;TEdge&gt;().Target.Equals(v)</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.IsAdjacentEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph">Contract.Result&lt;bool&gt;() == (ithis.AdjacentDegree(v) == 0)</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.IsolatedVertexPredicate`2.Test(`0)">
      <pure />
      <requires>v != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.IsolatedVertexPredicate`2.#ctor(QuickGraph.IBidirectionalGraph{`0,`1})">
      <requires>visitedGraph!=null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredImplicitVertexSet`3.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet">vertex != null</requires>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredBidirectionalGraph`3.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredBidirectionalGraph`3.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.IsInEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == (ithis.InDegree(v) == 0)</ensures>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredBidirectionalGraph`3.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.InEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">index &gt;= 0 &amp;&amp; index &lt; ithis.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;TEdge&gt;().Equals(Enumerable.ElementAt(ithis.InEdges(v), index))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.InEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Enumerable.All(
                Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), 
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.InDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.Degree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;int&gt;() == ithis.InDegree(v) + ithis.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">ithis.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">Contract.Result&lt;bool&gt;() == ithis.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || Contract.ValueAtReturn(out edges) != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph">!Contract.Result&lt;bool&gt;() || 
                Enumerable.All(
                Contract.ValueAtReturn&lt;IEnumerable&lt;TEdge&gt;&gt;(out edges),
                edge =&gt; edge != null &amp;&amp; edge.Target.Equals(v)
                )</ensures>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredEdgeListGraph`3.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet">Contract.Result&lt;bool&gt;() == (ithis.VertexCount == 0)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredEdgeListGraph`3.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet">Enumerable.All&lt;TEdge&gt;(Contract.Result&lt;IEnumerable&lt;TEdge&gt;&gt;(), e =&gt; e != null)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredEdgeListGraph`3.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Edges)</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredEdgeListGraph`3.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet">Contract.Result&lt;IEnumerable&lt;TVertex&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredEdgeListGraph`3.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == (ithis.EdgeCount == 0)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredEdgeListGraph`3.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">edge != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet">Contract.Result&lt;bool&gt;() == Contract.Exists(ithis.Edges, e =&gt; e.Equals(edge))</ensures>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredEdgeListGraph`3.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet">Contract.Result&lt;int&gt;() == Enumerable.Count(ithis.Vertices)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredEdgeListGraph`3.FilterEdge(`1)">
      <pure />
    </member>
    <member name="M:QuickGraph.Predicates.FilteredGraph`3.#ctor(`2,QuickGraph.VertexPredicate{`0},QuickGraph.EdgePredicate{`0,`1})">
      <requires>baseGraph != null</requires>
      <requires>vertexPredicate != null</requires>
      <requires>edgePredicate != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.ReversedResidualEdgePredicate`2.Test(`1)">
      <requires>e != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.ReversedResidualEdgePredicate`2.#ctor(System.Collections.Generic.IDictionary{`1,System.Double},System.Collections.Generic.IDictionary{`1,`1})">
      <requires>residualCapacities != null</requires>
      <requires>reversedEdges != null</requires>
    </member>
    <member name="M:QuickGraph.Contracts.GraphContract.InVertexSet``1(QuickGraph.IVertexSet{``0},``0)">
      <pure />
      <requires>g != null</requires>
      <requires>v != null</requires>
    </member>
    <member name="M:QuickGraph.Contracts.GraphContract.EdgeCountEqual``2(QuickGraph.IEdgeListGraph{``0,``1},QuickGraph.IEdgeListGraph{``0,``1})">
      <pure />
      <requires>left != null</requires>
      <requires>right != null</requires>
    </member>
    <member name="M:QuickGraph.Contracts.GraphContract.InEdgeSet``2(QuickGraph.IEdgeListGraph{``0,``1},``1)">
      <pure />
      <requires>g != null</requires>
      <requires>e != null</requires>
    </member>
    <member name="M:QuickGraph.Contracts.GraphContract.InVertexSet``2(QuickGraph.IEdgeListGraph{``0,``1},``1)">
      <pure />
      <requires>g != null</requires>
      <requires>e != null</requires>
    </member>
    <member name="M:QuickGraph.Contracts.GraphContract.VertexCountEqual``1(QuickGraph.IVertexSet{``0},QuickGraph.IVertexSet{``0})">
      <pure />
      <requires>left != null</requires>
      <requires>right != null</requires>
    </member>
    <member name="M:QuickGraph.VertexEventArgs`1.#ctor(`0)">
      <requires>vertex != null</requires>
    </member>
  </members>
</doc>